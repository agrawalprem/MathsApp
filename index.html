<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learning Maths in Baby Steps</title>
    <!-- Supabase JS Library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.3/dist/umd/supabase.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            min-height: 100dvh; /* Use dynamic viewport height for mobile */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Changed from center to flex-start for better mobile behavior */
            padding: 20px;
            /* Prevent layout shift when keyboard appears on mobile */
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            body {
                align-items: flex-start;
                padding: 10px;
                min-height: -webkit-fill-available; /* Better mobile support */
            }
            
            .container {
                margin-top: 0;
                padding: 20px 15px;
            }
            
            .question-container {
                margin-left: -15px;
                margin-right: -15px;
                padding-left: 15px;
                padding-right: 15px;
                /* Allow horizontal scroll for multi-digit table if needed */
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
        }

        /* Extra small mobile devices */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            .container {
                padding: 15px 10px;
                border-radius: 15px;
            }
            
            .question-container {
                margin-left: -10px;
                margin-right: -10px;
                padding-left: 10px;
                padding-right: 10px;
            }
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
            margin: auto;
            /* Prevent container from shifting when keyboard appears */
            position: relative;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .setup-section {
            margin-bottom: 30px;
        }

        .setup-section label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
        }

        .setup-section select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 15px;
        }

        /* Dashboard Styles */
        .dashboard-section {
            margin-bottom: 30px;
        }

        /* Inline Login Styles */
        .login-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .login-form {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .login-form input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
        }

        .login-form input:focus {
            outline: none;
            border-color: #667eea;
        }

        .login-error {
            color: #dc3545;
            font-size: 12px;
            margin-top: 8px;
            min-height: 16px;
        }

        .user-display {
            color: #28a745;
            font-size: 14px;
            margin-top: 8px;
            font-weight: 500;
        }

        .operations-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .operation-card {
            background: white;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 15px 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .operation-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            background: #f8f9ff;
        }

        .operation-card.selected {
            background: #e7f3ff;
            border-color: #2196F3;
        }

        .operation-card.completed {
            background: #d4edda;
            border-color: #28a745;
        }

        .operation-card.completed:hover {
            background: #c3e6cb;
        }

        .operation-symbol {
            font-size: 32px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .operation-name {
            font-size: 14px;
            color: #333;
            font-weight: 500;
        }

        .variants-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
            margin-top: 20px;
        }

        .variant-card {
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .variant-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            border-color: #667eea;
        }

        .variant-card.passed {
            background: #d4edda;
            border-color: #28a745;
            color: #155724;
        }

        .variant-card.passed:hover {
            background: #c3e6cb;
        }

        .variant-card.failed {
            background: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }

        .variant-card.failed:hover {
            background: #f5c6cb;
        }

        .variant-name {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 5px;
        }

        .variant-status {
            font-size: 12px;
            color: #666;
        }

        .variant-card.passed .variant-status {
            color: #155724;
            font-weight: 600;
        }

        .variant-card.failed .variant-status {
            color: #721c24;
            font-weight: 600;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s;
            width: 100%;
            font-weight: 600;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .question-container {
            margin-top: 30px;
            /* Keep question area stable on mobile when keyboard appears */
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .question-line {
            font-size: 32px;
            margin: 15px 0;
            text-align: right;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            font-weight: 600;
            color: #333;
            /* Prevent question from moving when keyboard appears */
            scroll-margin-top: 10px;
        }

        .question-line.multidigit {
            font-family: 'Courier New', monospace;
            letter-spacing: 8px;
        }

        .answer-input {
            font-size: 32px;
            text-align: right;
            border: 3px solid #667eea;
            border-radius: 8px;
            padding: 10px 15px;
            width: 100%;
            margin: 15px 0;
            font-weight: 600;
            /* Prevent input from causing scroll jump on mobile */
            scroll-margin-top: 20px;
        }

        .answer-input:focus {
            outline: none;
            border-color: #764ba2;
            /* Prevent auto-scroll on mobile when keyboard appears */
            scroll-behavior: auto;
        }

        /* Remove spinner arrows from number input */
        .answer-input::-webkit-outer-spin-button,
        .answer-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .answer-input[type=number] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        .answer-display {
            font-size: 32px;
            text-align: right;
            border: 3px solid #667eea;
            border-radius: 8px;
            padding: 10px 15px;
            width: 100%;
            margin: 15px 0;
            font-weight: 600;
            font-family: 'Courier New', monospace;
            letter-spacing: 8px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            background: white;
        }

        .answer-display:focus-within {
            border-color: #764ba2;
        }

        .answer-display .digit {
            display: inline-block;
            min-width: 24px;
            text-align: center;
        }

        .answer-display .placeholder {
            color: #ccc;
        }

        .answer-display .entered {
            color: #333;
        }

        .hidden-input {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }

        .multidigit-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 32px;
            font-weight: 600;
        }

        .multidigit-table td {
            border: 2px solid #667eea;
            padding: 15px;
            text-align: center;
            min-width: 60px;
            height: 60px;
            background: white;
        }

        .multidigit-table td.operation-cell {
            background: #f8f9fa;
            border-color: #764ba2;
            font-size: 36px;
        }

        .multidigit-table td.input-cell {
            background: #fff;
            border-color: #667eea;
            cursor: text;
            /* Ensure input cells are focusable on mobile */
            -webkit-tap-highlight-color: rgba(118, 75, 162, 0.3);
            touch-action: manipulation;
        }

        .multidigit-table td.input-cell.placeholder {
            color: #ccc;
        }

        .multidigit-table td.input-cell.entered {
            color: #333;
        }

        .multidigit-table td.input-cell:focus {
            outline: 3px solid #764ba2;
            outline-offset: -3px;
            /* Ensure focus is visible on mobile */
            -webkit-tap-highlight-color: rgba(118, 75, 162, 0.5);
        }

        /* Mobile-specific styles for multi-digit table */
        @media (max-width: 768px) {
            .multidigit-table {
                font-size: 20px;
                margin: 10px 0;
                /* Ensure table fits within viewport */
                width: 100%;
                table-layout: auto;
            }

            .multidigit-table td {
                padding: 8px 4px;
                min-width: 0;
                width: auto;
                height: 45px;
                border-width: 1.5px;
            }

            .multidigit-table td.operation-cell {
                font-size: 24px;
                padding: 8px 6px;
            }

            /* Ensure table doesn't exceed viewport width */
            .multidigit-table {
                max-width: 100%;
                box-sizing: border-box;
            }
        }

        /* Extra small mobile devices */
        @media (max-width: 480px) {
            .multidigit-table {
                font-size: 18px;
            }

            .multidigit-table td {
                padding: 6px 3px;
                height: 40px;
                font-size: 18px;
            }

            .multidigit-table td.operation-cell {
                font-size: 20px;
                padding: 6px 4px;
            }
            
            /* Adjust question-container margins for smaller screens */
            .question-container {
                margin-left: -10px;
                margin-right: -10px;
                padding-left: 10px;
                padding-right: 10px;
            }
        }

        .correct-answer {
            font-size: 24px;
            color: #dc3545;
            text-align: right;
            margin-top: 10px;
            min-height: 40px;
        }

        .timer {
            text-align: center;
            font-size: 20px;
            color: #667eea;
            margin: 15px 0;
            font-weight: 600;
        }

        .timer.warning {
            color: #dc3545;
        }

        .summary-section {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .summary-section h2 {
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        .summary-stats {
            margin-bottom: 20px;
        }

        .summary-stats p {
            margin: 8px 0;
            font-size: 16px;
            color: #555;
        }

        .pass-fail {
            text-align: center;
            font-size: 24px;
            font-weight: 700;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .pass {
            background: #d4edda;
            color: #155724;
        }

        .fail {
            background: #f8d7da;
            color: #721c24;
        }

        .question-details {
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .question-item {
            padding: 10px;
            margin: 8px 0;
            background: white;
            border-radius: 6px;
            border-left: 4px solid #667eea;
        }

        .question-item.wrong {
            border-left-color: #dc3545;
            color: #dc3545;
        }
        
        .question-item.wrong strong {
            color: #dc3545;
        }

        .question-item.correct {
            border-left-color: #28a745;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .modal-content h3 {
            margin-bottom: 20px;
            color: #333;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .modal-buttons button {
            flex: 1;
        }

        .hidden {
            display: none;
        }

        /* Authentication UI Styles */
        .auth-section {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .auth-status {
            margin-bottom: 10px;
        }

        .auth-status.logged-in {
            color: #28a745;
        }

        .auth-status.logged-out {
            color: #dc3545;
        }

        .auth-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .auth-buttons button {
            padding: 8px 20px;
            font-size: 14px;
        }

        .auth-buttons .btn-secondary {
            background: #6c757d;
        }

        .auth-buttons .btn-secondary:hover {
            background: #5a6268;
        }

        #authModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .auth-modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            position: relative;
        }

        .auth-modal-content h3 {
            margin-bottom: 20px;
            color: #333;
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .auth-form input {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
        }

        .auth-form input:focus {
            outline: none;
            border-color: #667eea;
        }

        .auth-error {
            color: #dc3545;
            font-size: 14px;
            margin-top: 10px;
            min-height: 20px;
        }

        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Learning Maths</h1>
            <p>in Baby Steps</p>
        </div>

        <!-- Dashboard (shown when logged in) -->
        <div id="dashboardSection" class="dashboard-section hidden">
            <!-- Login Form (part of dashboard) -->
            <div id="loginSection" class="login-section">
                <form class="login-form" onsubmit="return handleInlineLogin(event);">
                    <input type="email" id="inlineEmail" placeholder="Email" style="flex: 1; max-width: 200px;" required>
                    <input type="password" id="inlinePassword" placeholder="Password" style="flex: 1; max-width: 200px;" required>
                    <button type="submit" class="btn" id="inlineLoginBtn" style="flex: 0 0 auto;">Log In</button>
                    <button type="button" class="btn btn-secondary hidden" onclick="handleLogout()" id="inlineLogoutBtn" style="flex: 0 0 auto;">Log Out</button>
                </form>
                <div id="loginError" class="login-error"></div>
                <div id="userDisplay" class="user-display hidden"></div>
                <div style="margin-top: 10px; font-size: 14px; text-align: center;">
                    <a href="#" onclick="showForgotPasswordModal(); return false;" style="color: #667eea; text-decoration: none; font-weight: 500;">Forgot Password?</a>
                </div>
                <div id="signupLinkContainer" style="margin-top: 10px; font-size: 14px; text-align: center;">
                    <span>Don't have an account? </span>
                    <a href="#" onclick="showSignupModal(); return false;" style="color: #667eea; text-decoration: none; font-weight: 500;">Sign Up</a>
                </div>
            </div>
            
            <div id="guestNotice" class="guest-notice hidden" style="text-align: center; margin: 15px 0; padding: 10px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; color: #856404;">
                <strong>Note:</strong> You are not logged in. You can practice, but your results will not be saved. <a href="#" onclick="document.getElementById('inlineEmail').focus(); return false;" style="color: #667eea; text-decoration: underline;">Log in</a> to save your progress.
            </div>
            
            <h2 style="text-align: center; margin-bottom: 20px; color: #333;">Choose an Operation</h2>
            
            <!-- Operation Symbols -->
            <div class="operations-grid">
                <div class="operation-card" onclick="selectOperation('addition')">
                    <div class="operation-symbol">+</div>
                    <div class="operation-name">Addition</div>
                </div>
                <div class="operation-card" onclick="selectOperation('subtraction')">
                    <div class="operation-symbol">−</div>
                    <div class="operation-name">Subtraction</div>
                </div>
                <div class="operation-card" onclick="selectOperation('multiplication')">
                    <div class="operation-symbol">×</div>
                    <div class="operation-name">Multiplication</div>
                </div>
                <div class="operation-card" onclick="selectOperation('division')">
                    <div class="operation-symbol">÷</div>
                    <div class="operation-name">Division</div>
                </div>
            </div>

            <!-- Variants shown below selected operation -->
            <div id="variantsContainer" class="variants-container"></div>
        </div>


        <div id="questionSection" class="question-container hidden">
            <div class="timer hidden" id="timer">Time: 0.0s</div>
            <div class="question-line" id="line1"></div>
            <div class="question-line" id="line2"></div>
            <div class="question-line" id="answerLine">
                <input type="number" id="answerInput" class="answer-input" placeholder="?" autocomplete="off">
                <div id="answerDisplay" class="answer-display hidden" tabindex="0">
                    <input type="text" id="hiddenInput" class="hidden-input" autocomplete="off">
                </div>
                <table id="multidigitTable" class="multidigit-table hidden"></table>
            </div>
            <div class="correct-answer" id="line4"></div>
        </div>

        <div id="summarySection" class="summary-section hidden">
            <h2>Session Summary</h2>
            <div class="summary-stats" id="summaryStats"></div>
            <div class="pass-fail" id="passFail"></div>
            <div class="question-details" id="questionDetails"></div>
            <button class="btn" onclick="resetSession()" style="margin-top: 20px;">Go Back</button>
        </div>
    </div>

    <div id="modal" class="modal">
        <div class="modal-content">
            <h3>Session Termination</h3>
            <p>You have completed 50 questions. Would you like to continue or end the session?</p>
            <div class="modal-buttons">
                <button class="btn" onclick="continueSession()">Continue</button>
                <button class="btn" onclick="endSession()" style="background: #dc3545;">End Session</button>
            </div>
        </div>
    </div>

    <!-- Authentication Modal -->
    <div id="authModal" class="modal">
        <div class="auth-modal-content" style="max-width: 500px; max-height: 90vh; overflow-y: auto;">
            <span style="position: absolute; top: 10px; right: 15px; cursor: pointer; font-size: 24px; color: #999;" onclick="closeAuthModal()">&times;</span>
            <h3 id="authModalTitle">Log In</h3>
            <form id="authForm" class="auth-form" onsubmit="handleAuth(event)">
                <!-- Login fields (shown when isLoginMode = true) -->
                <div id="loginFields">
                    <input type="email" id="authEmail" placeholder="Email" required>
                    <input type="password" id="authPassword" placeholder="Password" required>
                </div>
                
                <!-- Signup fields (shown when isLoginMode = false) -->
                <div id="signupFields" style="display: none;">
                    <input type="email" id="signupEmail" placeholder="Email" required>
                    <input type="text" id="signupFirstName" placeholder="First Name" required>
                    <input type="text" id="signupLastName" placeholder="Last Name">
                    <select id="signupGender" required>
                        <option value="">Select Gender</option>
                        <option value="Male">Male</option>
                        <option value="Female">Female</option>
                        <option value="Other">Other</option>
                    </select>
                    <input type="number" id="signupSchoolId" placeholder="School ID" min="1" required>
                    <input type="number" id="signupClass" placeholder="Class" min="1" max="12" required>
                    <input type="text" id="signupSection" placeholder="Section (e.g., A, B)" required>
                    <input type="number" id="signupRollNumber" placeholder="Roll Number" min="1" required>
                    <input type="password" id="signupPassword" placeholder="Password" minlength="6" required>
                    <input type="password" id="signupPasswordConfirm" placeholder="Confirm Password" minlength="6" required>
                </div>
                
                <button type="submit" class="btn" id="authSubmitBtn">Submit</button>
            </form>
            <div id="authError" class="auth-error"></div>
            <div id="authToggle" style="margin-top: 15px; font-size: 14px;">
                <span id="authToggleText">Don't have an account? </span>
                <a href="#" onclick="toggleAuthMode(event)" style="color: #667eea; text-decoration: none;">Sign Up</a>
            </div>
            <div id="forgotPasswordLink" style="margin-top: 10px; font-size: 14px; text-align: center; display: none;">
                <a href="#" onclick="showForgotPasswordModal(); return false;" style="color: #667eea; text-decoration: none;">Forgot Password?</a>
            </div>
        </div>
    </div>

    <!-- Forgot Password Modal -->
    <div id="forgotPasswordModal" class="modal">
        <div class="auth-modal-content" style="max-width: 500px;">
            <span style="position: absolute; top: 10px; right: 15px; cursor: pointer; font-size: 24px; color: #999;" onclick="closeForgotPasswordModal()">&times;</span>
            <h3 id="forgotPasswordModalTitle">Reset Password</h3>
            <div id="forgotPasswordRequestForm">
                <p style="margin-bottom: 20px; color: #666;">Enter your email address and we'll send you a link to reset your password.</p>
                <form id="forgotPasswordForm" onsubmit="handleForgotPassword(event)">
                    <input type="email" id="forgotPasswordEmail" placeholder="Email" required style="width: 100%; margin-bottom: 15px;">
                    <button type="submit" class="btn" id="forgotPasswordSubmitBtn">Send Reset Link</button>
                </form>
                <div id="forgotPasswordError" class="auth-error" style="margin-top: 15px;"></div>
                <div id="forgotPasswordSuccess" style="margin-top: 15px; color: #28a745; display: none;"></div>
            </div>
            <div id="forgotPasswordResetForm" style="display: none;">
                <p style="margin-bottom: 20px; color: #666;">Enter your new password.</p>
                <form id="resetPasswordForm" onsubmit="handleResetPassword(event)">
                    <input type="password" id="newPassword" placeholder="New Password" minlength="6" required style="width: 100%; margin-bottom: 15px;">
                    <input type="password" id="confirmNewPassword" placeholder="Confirm New Password" minlength="6" required style="width: 100%; margin-bottom: 15px;">
                    <button type="submit" class="btn" id="resetPasswordSubmitBtn">Update Password</button>
                </form>
                <div id="resetPasswordError" class="auth-error" style="margin-top: 15px;"></div>
            </div>
            <div style="margin-top: 15px; font-size: 14px; text-align: center;">
                <a href="#" onclick="closeForgotPasswordModal(); showSignupModal(); return false;" style="color: #667eea; text-decoration: none;">Back to Login</a>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // MULTI-DIGIT VARIANTS SECTION
        // ============================================================================
        // All multi-digit variants are defined here. They share common features:
        // - Right-to-left cursor movement
        // - No time limit
        // - Multi-digit number formatting with spacing
        // - Special input handling
        //
        // To add a new multi-digit variant:
        // 1. Add it to the appropriate operation section below
        // 2. Include: first/second ranges, name, and any special flags (noCarry, etc.)
        // 3. The variant will automatically get: noTimeLimit: true, rightToLeft: true
        // ============================================================================
        
        const multiDigitVariants = {
            addition: {
                '1M1': {
                    first: [10000, 99999],
                    second: [10000, 99999],
                    name: '1M1: Adding Multi-digit Numbers without Carry',
                    noCarry: true,
                    maxQuestions: 10
                },
                '1M2': {
                    first: [10000, 99999],
                    second: [10000, 99999],
                    name: '1M2: Adding Multi-digit Numbers with Carry',
                    hasCarry: true,
                    maxQuestions: 10
                }
                // Add more multi-digit addition variants here:
                // '1M3': { ... },
            },
            subtraction: {
                '2M1': {
                    first: [10000, 99999],
                    second: [1000, 99999],
                    name: '2M1: Subtracting Multi-digit Numbers without Borrow',
                    noBorrow: true,
                    maxQuestions: 10
                },
                '2M2': {
                    first: [10000, 99999],
                    second: [1000, 99999],
                    name: '2M2: Subtracting Multi-digit Numbers with Borrow',
                    hasBorrow: true,
                    maxQuestions: 10
                },
                '2M3': {
                    first: [10000, 99999],
                    second: [1000, 99999],
                    name: '2M3: Subtracting Multi-digit Numbers with Borrow from 0',
                    hasBorrow: true,
                    hasBorrowFromZero: true,
                    maxQuestions: 10
                }
            },
            multiplication: {
                '3M1': {
                    first: [10000, 99999],
                    second: [0, 9],
                    name: '3M1: Multi-digit x 1-digit Multiplication 1',
                    noZero: true,
                    onePerSecond: true,
                    maxQuestions: 10
                },
                '3M2': {
                    first: [10000, 99999],
                    second: [0, 9],
                    name: '3M2: Multi-digit x 1-digit Multiplication 2',
                    hasZero: true,
                    onePerSecond: true,
                    maxQuestions: 10
                }
            },
            division: {
                '4M1': {
                    first: [10000, 99999],
                    second: [1, 9],
                    name: '4M1: Multi-digit by 1-digit Division 1',
                    noZero: true,
                    onePerSecond: true,
                    maxQuestions: 9
                },
                '4M2': {
                    first: [10000, 99999],
                    second: [1, 9],
                    name: '4M2: Multi-digit by 1-digit Division 2',
                    hasZero: true,
                    onePerSecond: true,
                    maxQuestions: 9
                }
            }
        };

        // Apply multi-digit flags to all multi-digit variants
        for (const operation in multiDigitVariants) {
            for (const variantKey in multiDigitVariants[operation]) {
                const variant = multiDigitVariants[operation][variantKey];
                variant.noTimeLimit = true;
                variant.rightToLeft = true;
            }
        }

        // ============================================================================
        // STANDARD VARIANTS
        // ============================================================================
        const variants = {
            addition: {
                '1A0': { first: [0, 9], second: [0, 0], name: '1A0: Adding 0' },
                '1A1': { first: [0, 9], second: [1, 1], name: '1A1: Adding 1' },
                '1A2': { first: [0, 9], second: [2, 2], name: '1A2: Adding 2' },
                '1A3': { first: [0, 9], second: [3, 3], name: '1A3: Adding 3' },
                '1A': { first: [0, 9], second: [0, 3], name: '1A: Adding 0, 1, 2, 3' },
                '1B': { first: [0, 3], second: [0, 9], name: '1B: Adding Bigger Number to Smaller Number' },
                '1C': { first: [0, 9], second: 'same', name: '1C: Both Numbers Same' },
                '1D': { first: [6, 9], second: [6, 9], name: '1D: Adding Large Numbers (6-9)', excludeSame: true },
                '1': { first: [0, 9], second: [0, 9], name: '1: Adding Single-digit Numbers (0-9)' }
            },
            subtraction: {
                '2A': { second: [0, 4], result: [0, 4], name: '2A: Subtracting (0-4), Result (0-4)' },
                '2B': { second: [0, 4], result: [5, 9], name: '2B: Subtracting (0-4), Result (5-9)' },
                '2C': { second: [5, 9], result: [0, 4], name: '2C: Subtracting (5-9), Result (0-4)' },
                '2D': { second: [5, 9], result: [5, 9], name: '2D: Subtracting (5-9), Result (5-9)' },
                '2': { second: [0, 9], result: [0, 9], name: '2: Subtracting Single-digit Numbers (0-9)' }
            },
            multiplication: {
                '3A0': { first: [0, 0], second: [0, 9], name: '3A0: Multiplying 0 by any Number' },
                '3A1': { first: [1, 1], second: [0, 9], name: '3A1: Multiplying 1 by any Number' },
                '3A2S': { first: [2, 2], second: [0, 9], name: '3A2S: Table of 2', sequential: true },
                '3A2': { first: [2, 2], second: [0, 9], name: '3A2: Table of 2 Random' },
                '3A3S': { first: [3, 3], second: [0, 9], name: '3A3S: Table of 3', sequential: true },
                '3A3': { first: [3, 3], second: [0, 9], name: '3A3: Table of 3 Random' },
                '3A': { first: [0, 3], second: [0, 9], name: '3A: Multiplying 0, 1, 2, 3 by any Number' },
                '3B4S': { first: [4, 4], second: [0, 9], name: '3B4S: Table of 4', sequential: true },
                '3B4': { first: [4, 4], second: [0, 9], name: '3B4: Table of 4 Random' },
                '3B5S': { first: [5, 5], second: [0, 9], name: '3B5S: Table of 5', sequential: true },
                '3B5': { first: [5, 5], second: [0, 9], name: '3B5: Table of 5 Random' },
                '3B6S': { first: [6, 6], second: [0, 9], name: '3B6S: Table of 6', sequential: true },
                '3B6': { first: [6, 6], second: [0, 9], name: '3B6: Table of 6 Random' },
                '3B': { first: [4, 6], second: [0, 9], name: '3B: Multiplying 4, 5, 6 by any Number' },
                '3C7S': { first: [7, 7], second: [0, 9], name: '3C7S: Table of 7', sequential: true },
                '3C7': { first: [7, 7], second: [0, 9], name: '3C7: Table of 7 Random' },
                '3C8S': { first: [8, 8], second: [0, 9], name: '3C8S: Table of 8', sequential: true },
                '3C8': { first: [8, 8], second: [0, 9], name: '3C8: Table of 8 Random' },
                '3C9S': { first: [9, 9], second: [0, 9], name: '3C9S: Table of 9', sequential: true },
                '3C9': { first: [9, 9], second: [0, 9], name: '3C9: Table of 9 Random' },
                '3C': { first: [7, 9], second: [0, 9], name: '3C: Multiplying 7, 8, 9 by any Number' },
                '3': { first: [0, 9], second: [0, 9], name: '3: Multiplying Single-digit Numbers' }
            },
            division: {
                '4A1': { second: [1, 1], result: [0, 9], name: '4A1: Dividing by 1' },
                '4A2': { second: [2, 2], result: [0, 9], name: '4A2: Dividing by 2' },
                '4A3': { second: [3, 3], result: [0, 9], name: '4A3: Dividing by 3' },
                '4A': { second: [1, 3], result: [0, 9], name: '4A: Dividing by 1, 2, 3' },
                '4B4': { second: [4, 4], result: [0, 9], name: '4B4: Dividing by 4' },
                '4B5': { second: [5, 5], result: [0, 9], name: '4B5: Dividing by 5' },
                '4B6': { second: [6, 6], result: [0, 9], name: '4B6: Dividing by 6' },
                '4B': { second: [4, 6], result: [0, 9], name: '4B: Dividing by 4, 5, 6' },
                '4C7': { second: [7, 7], result: [0, 9], name: '4C7: Dividing by 7' },
                '4C8': { second: [8, 8], result: [0, 9], name: '4C8: Dividing by 8' },
                '4C9': { second: [9, 9], result: [0, 9], name: '4C9: Dividing by 9' },
                '4C': { second: [7, 9], result: [0, 9], name: '4C: Dividing by 7, 8, 9' },
                '4': { second: [1, 9], result: [0, 9], name: '4: Dividing Single-digit Numbers (1-9)' }
            }
        };

        // Merge multi-digit variants into main variants object
        for (const operation in multiDigitVariants) {
            if (variants[operation]) {
                Object.assign(variants[operation], multiDigitVariants[operation]);
            }
        }

        let currentSession = {
            operation: '',
            variant: '',
            questions: [],
            askedQuestions: new Set(),
            questionIndex: 0,
            correctCount: 0,
            wrongCount: 0,
            totalTime: 0,
            results: []
        };

        let timerInterval = null;
        let timeElapsed = 0;
        let questionStartTime = 0;
        let answerTimeout = null;

        function startSession(operation, variant) {
            // Use provided operation and variant, or fall back to currentSession if already set
            if (!operation) operation = currentSession?.operation;
            if (!variant) variant = currentSession?.variant;

            if (!operation || !variant) {
                console.error('Operation and variant are required to start a session');
                return;
            }

            currentSession = {
                operation: operation,
                variant: variant,
                questions: [],
                askedQuestions: new Set(),
                questionIndex: 0,
                correctCount: 0,
                wrongCount: 0,
                totalTime: 0,
                results: []
            };

            generateAllQuestions(operation, variant);
            document.getElementById('questionSection').classList.remove('hidden');
            document.getElementById('summarySection').classList.add('hidden');
            
            askNextQuestion();
        }

        function hasNoCarry(first, second) {
            // Convert numbers to strings to check digit by digit
            const firstStr = first.toString();
            const secondStr = second.toString();
            const maxLength = Math.max(firstStr.length, secondStr.length);
            
            // Pad shorter number with leading zeros
            const firstPadded = firstStr.padStart(maxLength, '0');
            const secondPadded = secondStr.padStart(maxLength, '0');
            
            // Check each digit position from right to left
            for (let i = maxLength - 1; i >= 0; i--) {
                const digit1 = parseInt(firstPadded[i]);
                const digit2 = parseInt(secondPadded[i]);
                if (digit1 + digit2 >= 10) {
                    return false; // Has carry
                }
            }
            return true; // No carry
        }

        function hasBorrow(first, second) {
            // Convert numbers to strings to check digit by digit
            const firstStr = first.toString();
            const secondStr = second.toString();
            const maxLength = Math.max(firstStr.length, secondStr.length);
            
            // Pad shorter number with leading zeros
            const firstPadded = firstStr.padStart(maxLength, '0');
            const secondPadded = secondStr.padStart(maxLength, '0');
            
            // Check each digit position from right to left
            let needsBorrow = false;
            for (let i = maxLength - 1; i >= 0; i--) {
                const firstDigit = parseInt(firstPadded[i]);
                const secondDigit = parseInt(secondPadded[i]);
                if (firstDigit < secondDigit) {
                    needsBorrow = true;
                    break;
                }
            }
            return needsBorrow;
        }

        function hasCarry(first, second) {
            // Convert numbers to strings to check digit by digit
            const firstStr = first.toString();
            const secondStr = second.toString();
            const maxLength = Math.max(firstStr.length, secondStr.length);
            
            // Pad shorter number with leading zeros
            const firstPadded = firstStr.padStart(maxLength, '0');
            const secondPadded = secondStr.padStart(maxLength, '0');
            
            // Check each digit position from right to left
            for (let i = maxLength - 1; i >= 0; i--) {
                const digit1 = parseInt(firstPadded[i]);
                const digit2 = parseInt(secondPadded[i]);
                if (digit1 + digit2 >= 10) {
                    return true; // Has carry
                }
            }
            return false; // No carry
        }

        function generateAllQuestions(operation, variant) {
            const variantConfig = variants[operation][variant];
            const allQuestions = [];

            if (operation === 'addition') {
                const firstRange = variantConfig.first;
                const secondRange = variantConfig.second;

                if (variantConfig.noCarry) {
                    // Special handling for multi-digit addition without carry
                    // More efficient: generate first number, then construct second number digit by digit
                    const maxQuestions = variantConfig.maxQuestions || 10;
                    const usedQuestions = new Set();
                    let attempts = 0;
                    const maxAttempts = 10000; // Safety limit
                    
                    while (allQuestions.length < maxQuestions && attempts < maxAttempts) {
                        attempts++;
                        // Generate first number randomly
                        const first = Math.floor(Math.random() * (firstRange[1] - firstRange[0] + 1)) + firstRange[0];
                        const firstStr = first.toString();
                        const firstDigits = firstStr.split('').map(d => parseInt(d));
                        
                        // Construct second number digit by digit (right to left)
                        // For each position, determine valid digits that won't cause carry
                        const secondDigits = [];
                        const numDigits = firstStr.length;
                        
                        for (let i = numDigits - 1; i >= 0; i--) {
                            const firstDigit = firstDigits[i];
                            // Valid digits for this position: 0 to (9 - firstDigit) to avoid carry
                            const maxValidDigit = 9 - firstDigit;
                            const validDigits = [];
                            
                            // Build list of valid digits (0 to maxValidDigit)
                            for (let d = 0; d <= maxValidDigit; d++) {
                                validDigits.push(d);
                            }
                            
                            // Randomly select one valid digit
                            if (validDigits.length > 0) {
                                const randomIndex = Math.floor(Math.random() * validDigits.length);
                                secondDigits.unshift(validDigits[randomIndex]);
                            } else {
                                // Should not happen, but if it does, skip this attempt
                                break;
                            }
                        }
                        
                        // Convert second number array to actual number
                        const second = parseInt(secondDigits.join(''));
                        
                        // Check if second number is within range (should always be true for same-length numbers)
                        if (second >= secondRange[0] && second <= secondRange[1]) {
                            const questionKey = `${first}_${second}_${first + second}`;
                            
                            // Check if we already have this question
                            if (!usedQuestions.has(questionKey)) {
                                usedQuestions.add(questionKey);
                                allQuestions.push({ first: first, second: second, answer: first + second });
                            }
                        }
                    }
                } else if (variantConfig.hasCarry) {
                    // Special handling for multi-digit addition with carry
                    const maxQuestions = variantConfig.maxQuestions || 10;
                    let attempts = 0;
                    const maxAttempts = 100000; // Prevent infinite loop
                    
                    while (allQuestions.length < maxQuestions && attempts < maxAttempts) {
                        attempts++;
                        const first = Math.floor(Math.random() * (firstRange[1] - firstRange[0] + 1)) + firstRange[0];
                        const second = Math.floor(Math.random() * (secondRange[1] - secondRange[0] + 1)) + secondRange[0];
                        
                        if (hasCarry(first, second)) {
                            const questionKey = `${first}_${second}_${first + second}`;
                            // Check if we already have this question
                            if (!allQuestions.some(q => q.first === first && q.second === second)) {
                                allQuestions.push({ first: first, second: second, answer: first + second });
                            }
                        }
                    }
                } else if (secondRange === 'same') {
                    for (let i = firstRange[0]; i <= firstRange[1]; i++) {
                        allQuestions.push({ first: i, second: i, answer: i + i });
                    }
                } else {
                    for (let i = firstRange[0]; i <= firstRange[1]; i++) {
                        for (let j = secondRange[0]; j <= secondRange[1]; j++) {
                            if (variantConfig.excludeSame && i === j) continue;
                            allQuestions.push({ first: i, second: j, answer: i + j });
                        }
                    }
                }
            } else if (operation === 'subtraction') {
                const secondRange = variantConfig.second;
                const resultRange = variantConfig.result;
                const firstRange = variantConfig.first; // For multi-digit variants

                if (variantConfig.noBorrow) {
                    // Special handling for multi-digit subtraction without borrow
                    const maxQuestions = variantConfig.maxQuestions || 10;
                    const usedQuestions = new Set();
                    let attempts = 0;
                    const maxAttempts = 10000;
                    
                    while (allQuestions.length < maxQuestions && attempts < maxAttempts) {
                        attempts++;
                        const first = Math.floor(Math.random() * (firstRange[1] - firstRange[0] + 1)) + firstRange[0];
                        const firstStr = first.toString();
                        const firstDigits = firstStr.split('').map(d => parseInt(d));
                        
                        // Construct second number digit by digit (right to left) to avoid borrow
                        const secondDigits = [];
                        const numDigits = firstStr.length;
                        
                        for (let i = numDigits - 1; i >= 0; i--) {
                            const firstDigit = firstDigits[i];
                            // Valid digits: 0 to firstDigit (to avoid borrow)
                            const maxValidDigit = firstDigit;
                            const validDigits = [];
                            
                            for (let d = 0; d <= maxValidDigit; d++) {
                                validDigits.push(d);
                            }
                            
                            if (validDigits.length > 0) {
                                const randomIndex = Math.floor(Math.random() * validDigits.length);
                                secondDigits.unshift(validDigits[randomIndex]);
                            } else {
                                break;
                            }
                        }
                        
                        const second = parseInt(secondDigits.join(''));
                        const result = first - second;
                        
                        if (result >= 0 && (!secondRange || (second >= secondRange[0] && second <= secondRange[1]))) {
                            const questionKey = `${first}_${second}_${result}`;
                            if (!usedQuestions.has(questionKey)) {
                                usedQuestions.add(questionKey);
                                allQuestions.push({ first: first, second: second, answer: result });
                            }
                        }
                    }
                } else if (variantConfig.hasBorrow) {
                    // Special handling for multi-digit subtraction with borrow
                    const maxQuestions = variantConfig.maxQuestions || 10;
                    const usedQuestions = new Set();
                    let attempts = 0;
                    const maxAttempts = 100000;
                    
                    while (allQuestions.length < maxQuestions && attempts < maxAttempts) {
                        attempts++;
                        
                        let firstStr = '';
                        const firstNumDigits = firstRange[1].toString().length; // Get number of digits from max
                        
                        if (variantConfig.hasBorrowFromZero) {
                            // 2M3: First number must have at least 2 zeros (but first digit cannot be 0)
                            // Generate first number with at least 2 zeros
                            const zeroPositions = new Set();
                            // Choose number of zeros: at least 2, up to numDigits-2 (since first digit can't be 0)
                            const maxZeros = firstNumDigits - 2; // Leave room for non-zero first digit
                            const numZeros = maxZeros >= 2 ? (Math.floor(Math.random() * (maxZeros - 1)) + 2) : 2; // At least 2 zeros
                            
                            // Randomly select positions for zeros (at least 2, but not position 0)
                            while (zeroPositions.size < numZeros && zeroPositions.size < firstNumDigits - 2) {
                                const pos = Math.floor(Math.random() * (firstNumDigits - 1)) + 1; // Positions 1 to numDigits-1 (skip first position)
                                zeroPositions.add(pos);
                            }
                            
                            // Generate first number digit by digit
                            for (let i = 0; i < firstNumDigits; i++) {
                                if (i === 0) {
                                    // First digit must be non-zero
                                    firstStr += Math.floor(Math.random() * 9) + 1; // 1 to 9
                                } else if (zeroPositions.has(i)) {
                                    firstStr += '0';
                                } else {
                                    firstStr += Math.floor(Math.random() * 9) + 1; // 1 to 9 (non-zero)
                                }
                            }
                        } else {
                            // 2M2: First number must have no zeros (all digits 1-9)
                            // For 5-digit: range is 11111 to 99999 (all digits 1-9)
                            for (let i = 0; i < firstNumDigits; i++) {
                                // Each digit is 1-9 (no zeros)
                                firstStr += Math.floor(Math.random() * 9) + 1; // 1 to 9
                            }
                        }
                        
                        const first = parseInt(firstStr);
                        
                        // Ensure first number is valid (not all zeros, and within range)
                        if (first === 0 || first < firstRange[0] || first > firstRange[1]) {
                            continue;
                        }
                        
                        // Generate second number randomly, smaller than first
                        let second;
                        if (variantConfig.hasBorrowFromZero) {
                            // 2M3: Second number can be any length (4 or 5 digits)
                            const secondMax = Math.min(secondRange[1] || first - 1, first - 1);
                            const secondMin = secondRange[0] || 1;
                            second = Math.floor(Math.random() * (secondMax - secondMin + 1)) + secondMin;
                        } else {
                            // 2M2: Second number should also be 5-digit (10000 to first-1)
                            // Ensure second number is same length as first (5-digit)
                            const secondMin = 10000; // Minimum 5-digit number
                            const secondMax = first - 1; // Must be smaller than first
                            if (secondMax < secondMin) {
                                continue; // Skip if first is too small (shouldn't happen)
                            }
                            second = Math.floor(Math.random() * (secondMax - secondMin + 1)) + secondMin;
                        }
                        
                        // Ensure second is smaller than first and has borrow
                        if (first > second && hasBorrow(first, second)) {
                            const questionKey = `${first}_${second}_${first - second}`;
                            if (!usedQuestions.has(questionKey)) {
                                usedQuestions.add(questionKey);
                                allQuestions.push({ first: first, second: second, answer: first - second });
                            }
                        }
                    }
                } else {
                    // Standard single-digit subtraction
                    for (let second = secondRange[0]; second <= secondRange[1]; second++) {
                        for (let result = resultRange[0]; result <= resultRange[1]; result++) {
                            const first = second + result;
                            // No limit on first number for subtraction
                            allQuestions.push({ first: first, second: second, answer: result });
                        }
                    }
                }
            } else if (operation === 'multiplication') {
                const firstRange = variantConfig.first;
                const secondRange = variantConfig.second;

                if (variantConfig.onePerSecond) {
                    // 3M1 and 3M2: One question for each second number (0-9), random first number
                    // First number: 5-digit, randomly generated
                    // 3M1: no zeros, 3M2: at least 1 zero
                    const firstNumDigits = firstRange[1].toString().length; // 5 digits
                    let first;
                    
                    // Generate one first number for the entire session
                    let attempts = 0;
                    const maxAttempts = 10000;
                    
                    while (attempts < maxAttempts) {
                        attempts++;
                        // Generate random 5-digit number (10000 to 99999)
                        first = Math.floor(Math.random() * (firstRange[1] - firstRange[0] + 1)) + firstRange[0];
                        const firstStr = first.toString();
                        
                        if (variantConfig.noZero) {
                            // 3M1: Check for absence of zero
                            if (!firstStr.includes('0')) {
                                break; // Found a number with no zeros
                            }
                        } else if (variantConfig.hasZero) {
                            // 3M2: Check for presence of zero
                            if (firstStr.includes('0')) {
                                break; // Found a number with at least one zero
                            }
                        } else {
                            // No constraint, use any valid number
                            break;
                        }
                    }
                    
                    if (!first || first < firstRange[0] || first > firstRange[1]) {
                        console.error('Failed to generate valid first number for multiplication variant');
                        return; // Exit if we can't generate a valid first number
                    }
                    
                    // Generate exactly one question for each second number (0-9), total 10 questions
                    // Use a Set to ensure no duplicate second numbers
                    const usedSeconds = new Set();
                    for (let second = secondRange[0]; second <= secondRange[1]; second++) {
                        if (!usedSeconds.has(second)) {
                            usedSeconds.add(second);
                            allQuestions.push({ first: first, second: second, answer: first * second });
                        }
                    }
                    
                    // Ensure we have exactly 10 questions (one for each digit 0-9)
                    if (allQuestions.length !== 10) {
                        console.warn(`Expected 10 questions but generated ${allQuestions.length} for ${variantConfig.name}`);
                    }
                    
                    // Shuffle questions to randomize sequence of second number
                    for (let i = allQuestions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [allQuestions[i], allQuestions[j]] = [allQuestions[j], allQuestions[i]];
                    }
                } else if (variantConfig.maxQuestions) {
                    // Multi-digit multiplication: generate limited random questions
                    const maxQuestions = variantConfig.maxQuestions;
                    const usedQuestions = new Set();
                    let attempts = 0;
                    const maxAttempts = 10000;
                    
                    while (allQuestions.length < maxQuestions && attempts < maxAttempts) {
                        attempts++;
                        const first = Math.floor(Math.random() * (firstRange[1] - firstRange[0] + 1)) + firstRange[0];
                        const second = Math.floor(Math.random() * (secondRange[1] - secondRange[0] + 1)) + secondRange[0];
                        const questionKey = `${first}_${second}_${first * second}`;
                        
                        if (!usedQuestions.has(questionKey)) {
                            usedQuestions.add(questionKey);
                            allQuestions.push({ first: first, second: second, answer: first * second });
                        }
                    }
                } else if (variantConfig.sequential) {
                    // Sequential variants: generate questions in order (0-9 for second number)
                    const first = firstRange[0]; // For sequential, first number is fixed
                    for (let j = secondRange[0]; j <= secondRange[1]; j++) {
                        allQuestions.push({ first: first, second: j, answer: first * j });
                    }
                } else {
                    // Random variants: generate all combinations
                    for (let i = firstRange[0]; i <= firstRange[1]; i++) {
                        for (let j = secondRange[0]; j <= secondRange[1]; j++) {
                            allQuestions.push({ first: i, second: j, answer: i * j });
                        }
                    }
                }
            } else if (operation === 'division') {
                const secondRange = variantConfig.second;
                const resultRange = variantConfig.result;

                if (variantConfig.onePerSecond) {
                    // 4M1 and 4M2: One question for each second number (1-9)
                    // First number: 5-digit, randomly generated
                    // 4M1: no zeros, 4M2: at least 1 zero
                    // If division has remainder, subtract remainder from first number
                    // Check adjusted first number still meets zero requirements
                    const firstRange = variantConfig.first || [10000, 99999];
                    const firstNumDigits = firstRange[1].toString().length; // 5 digits
                    let baseFirst;
                    
                    // Helper function to check if number has zeros
                    function hasZeros(num) {
                        return num.toString().includes('0');
                    }
                    
                    // Helper function to count zeros
                    function countZeros(num) {
                        return (num.toString().match(/0/g) || []).length;
                    }
                    
                    // Generate one base first number for the entire session
                    let attempts = 0;
                    const maxAttempts = 1000;
                    while (attempts < maxAttempts) {
                        attempts++;
                        let firstStr = '';
                        
                        if (variantConfig.noZero) {
                            // 4M1: First number with no zeros (all digits 1-9)
                            for (let i = 0; i < firstNumDigits; i++) {
                                firstStr += Math.floor(Math.random() * 9) + 1; // 1 to 9
                            }
                        } else if (variantConfig.hasZero) {
                            // 4M2: First number with at least 1 zero
                            const zeroPositions = new Set();
                            const numZeros = Math.floor(Math.random() * (firstNumDigits - 1)) + 1; // At least 1 zero
                            
                            // Randomly select positions for zeros (but not first position)
                            while (zeroPositions.size < numZeros && zeroPositions.size < firstNumDigits - 1) {
                                const pos = Math.floor(Math.random() * (firstNumDigits - 1)) + 1; // Positions 1 to 4
                                zeroPositions.add(pos);
                            }
                            
                            for (let i = 0; i < firstNumDigits; i++) {
                                if (i === 0) {
                                    // First digit must be non-zero
                                    firstStr += Math.floor(Math.random() * 9) + 1; // 1 to 9
                                } else if (zeroPositions.has(i)) {
                                    firstStr += '0';
                                } else {
                                    firstStr += Math.floor(Math.random() * 9) + 1; // 1 to 9
                                }
                            }
                        } else {
                            // Fallback: random 5-digit number
                            baseFirst = Math.floor(Math.random() * (firstRange[1] - firstRange[0] + 1)) + firstRange[0];
                            break;
                        }
                        
                        baseFirst = parseInt(firstStr);
                        if (baseFirst >= firstRange[0] && baseFirst <= firstRange[1] && baseFirst > 0) {
                            break;
                        }
                    }
                    
                    if (!baseFirst || baseFirst < firstRange[0] || baseFirst > firstRange[1]) {
                        console.error('Failed to generate valid first number for division variant');
                        return; // Exit if we can't generate a valid first number
                    }
                    
                    // Generate one question for each second number (1-9)
                    // Adjust first number if remainder exists
                    for (let second = secondRange[0]; second <= secondRange[1]; second++) {
                        let adjustedFirst = baseFirst;
                        const remainder = adjustedFirst % second;
                        
                        // If there's a remainder, subtract it from first number
                        if (remainder > 0) {
                            adjustedFirst = adjustedFirst - remainder;
                            
                            // Check if adjusted first number still meets zero requirements
                            let valid = false;
                            if (variantConfig.noZero) {
                                // 4M1: Adjusted first should have no zeros
                                valid = !hasZeros(adjustedFirst) && adjustedFirst >= 10000;
                            } else if (variantConfig.hasZero) {
                                // 4M2: Adjusted first should have at least 1 zero
                                valid = countZeros(adjustedFirst) >= 1 && adjustedFirst >= 10000;
                            } else {
                                valid = adjustedFirst >= firstRange[0];
                            }
                            
                            if (!valid) {
                                // Try adding multiples of second to find valid first number
                                let foundValid = false;
                                for (let multiple = 1; multiple <= 100 && !foundValid; multiple++) {
                                    const testFirst = baseFirst - remainder + (second * multiple);
                                    if (testFirst < firstRange[0] || testFirst > firstRange[1]) continue;
                                    
                                    if (variantConfig.noZero) {
                                        if (!hasZeros(testFirst) && testFirst >= 10000) {
                                            adjustedFirst = testFirst;
                                            foundValid = true;
                                        }
                                    } else if (variantConfig.hasZero) {
                                        if (countZeros(testFirst) >= 1 && testFirst >= 10000) {
                                            adjustedFirst = testFirst;
                                            foundValid = true;
                                        }
                                    } else {
                                        adjustedFirst = testFirst;
                                        foundValid = true;
                                    }
                                }
                                
                                // If still not valid, try subtracting multiples
                                if (!foundValid) {
                                    for (let multiple = 1; multiple <= remainder && !foundValid; multiple++) {
                                        const testFirst = baseFirst - remainder - (second * multiple);
                                        if (testFirst < firstRange[0] || testFirst > firstRange[1]) break;
                                        
                                        if (variantConfig.noZero) {
                                            if (!hasZeros(testFirst) && testFirst >= 10000) {
                                                adjustedFirst = testFirst;
                                                foundValid = true;
                                            }
                                        } else if (variantConfig.hasZero) {
                                            if (countZeros(testFirst) >= 1 && testFirst >= 10000) {
                                                adjustedFirst = testFirst;
                                                foundValid = true;
                                            }
                                        } else {
                                            adjustedFirst = testFirst;
                                            foundValid = true;
                                        }
                                    }
                                }
                                
                                // If still not valid, use the base adjustment (might have zeros but will still work)
                                if (!foundValid) {
                                    adjustedFirst = baseFirst - remainder;
                                }
                            }
                        }
                        
                        const result = Math.floor(adjustedFirst / second);
                        allQuestions.push({ first: adjustedFirst, second: second, answer: result });
                    }
                    
                    // Shuffle questions to randomize sequence of second number
                    for (let i = allQuestions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [allQuestions[i], allQuestions[j]] = [allQuestions[j], allQuestions[i]];
                    }
                } else if (variantConfig.maxQuestions) {
                    // Multi-digit division: generate limited random questions
                    const maxQuestions = variantConfig.maxQuestions;
                    const usedQuestions = new Set();
                    let attempts = 0;
                    const maxAttempts = 10000;
                    
                    while (allQuestions.length < maxQuestions && attempts < maxAttempts) {
                        attempts++;
                        const second = Math.floor(Math.random() * (secondRange[1] - secondRange[0] + 1)) + secondRange[0];
                        const result = Math.floor(Math.random() * (resultRange[1] - resultRange[0] + 1)) + resultRange[0];
                        const first = second * result;
                        const questionKey = `${first}_${second}_${result}`;
                        
                        if (!usedQuestions.has(questionKey)) {
                            usedQuestions.add(questionKey);
                            allQuestions.push({ first: first, second: second, answer: result });
                        }
                    }
                } else {
                    // Standard single-digit division
                    for (let second = secondRange[0]; second <= secondRange[1]; second++) {
                        for (let result = resultRange[0]; result <= resultRange[1]; result++) {
                            const first = second * result;
                            // No limit on first number for division
                            allQuestions.push({ first: first, second: second, answer: result });
                        }
                    }
                }
            }

            // Shuffle questions (except sequential variants which are already in order)
            if (!variantConfig.sequential) {
                for (let i = allQuestions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allQuestions[i], allQuestions[j]] = [allQuestions[j], allQuestions[i]];
                }
            }

            currentSession.questions = allQuestions;
        }

        function askNextQuestion() {
            // Check if we've asked 50 questions and need to prompt
            if (currentSession.questionIndex === 50 && currentSession.questions.length > 50) {
                showTerminationModal();
                return;
            }

            // Check if all questions have been asked
            if (currentSession.questionIndex >= currentSession.questions.length) {
                console.log('✅ All questions completed. Question index:', currentSession.questionIndex, 'Total questions:', currentSession.questions.length);
                endSession();
                return;
            }

            const question = currentSession.questions[currentSession.questionIndex];
            const questionKey = `${question.first}_${question.second}_${question.answer}`;

            // Skip if already asked (shouldn't happen, but safety check)
            if (currentSession.askedQuestions.has(questionKey)) {
                currentSession.questionIndex++;
                askNextQuestion();
                return;
            }

            currentSession.askedQuestions.add(questionKey);
            displayQuestion(question);
            startTimer();
        }

        function displayQuestion(question) {
            const operation = currentSession.operation;
            const variantConfig = variants[operation][currentSession.variant];
            let opSymbol = '+';
            if (operation === 'subtraction') opSymbol = '-';
            else if (operation === 'multiplication') opSymbol = '×';
            else if (operation === 'division') opSymbol = '÷';

            const line1 = document.getElementById('line1');
            const line2 = document.getElementById('line2');
            
            // Check if this is multi-digit variant (uses table layout)
            const isMultiDigit = variantConfig.rightToLeft;
            
            if (isMultiDigit) {
                // Hide regular lines, table will be shown
                line1.classList.add('hidden');
                line2.classList.add('hidden');
            } else {
                // Show regular lines
                line1.classList.remove('hidden');
                line2.classList.remove('hidden');
                line1.textContent = question.first;
                line2.textContent = `${opSymbol} ${question.second}`;
                line1.classList.remove('multidigit');
                line2.classList.remove('multidigit');
            }
            
            // Clear line4, but for multi-digit variants we'll use table row 4 instead
            if (!variantConfig.rightToLeft) {
                document.getElementById('line4').textContent = '';
            }
            
            // Scroll question area to top on mobile to keep it visible when keyboard appears
            // Use requestAnimationFrame to ensure DOM is updated first, then scroll smoothly
            requestAnimationFrame(() => {
                // Only scroll on mobile devices
                if (window.innerWidth <= 768) {
                    const questionContainer = document.querySelector('.question-container');
                    if (questionContainer) {
                        // Scroll container to top so sticky question stays visible
                        questionContainer.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
                    }
                }
            });
            
            // Determine required digits for answer
            const requiredDigits = question.answer.toString().length;
            
            // Check if right-to-left input is needed (multi-digit variants)
            if (variantConfig.rightToLeft) {
                setupRightToLeftInput(question, requiredDigits);
            } else {
                setupNormalInput(question, requiredDigits);
            }

            timeElapsed = 0;
            questionStartTime = Date.now();
        }

        function setupNormalInput(question, requiredDigits) {
            const answerDisplay = document.getElementById('answerDisplay');
            const input = document.getElementById('answerInput');
            const multidigitTable = document.getElementById('multidigitTable');
            
            answerDisplay.classList.add('hidden');
            multidigitTable.classList.add('hidden');
            input.classList.remove('hidden');
            input.value = '';
            input.disabled = false;
            // Reset background color to white for new question
            input.style.backgroundColor = 'white';
            input.style.transition = '';
            
            // Remove previous event listeners by cloning
            const newInput = input.cloneNode(true);
            input.parentNode.replaceChild(newInput, input);
            
            newInput.addEventListener('input', function() {
                const userAnswer = this.value;
                if (userAnswer.length >= requiredDigits) {
                    const parsed = parseInt(userAnswer);
                    checkAnswer(question, isNaN(parsed) ? null : parsed);
                }
            });

            // Focus on the new input after it's added to DOM
            // Prevent aggressive auto-scroll on mobile when keyboard appears
            setTimeout(() => {
                newInput.focus();
                // Don't select text on mobile as it can cause issues
                if (window.innerWidth > 768) {
                    newInput.select();
                }
            }, 50);
            
            // Minimize scroll jump when keyboard appears on mobile
            newInput.addEventListener('focus', function() {
                // Let sticky positioning handle keeping question visible
                // Only make minimal scroll adjustment if input is completely hidden
                setTimeout(() => {
                    const rect = this.getBoundingClientRect();
                    const viewportHeight = window.innerHeight;
                    // If input is mostly below viewport (keyboard visible), make minimal scroll
                    // Use 'nearest' to prevent excessive jumping
                    if (rect.bottom > viewportHeight * 0.9) {
                        this.scrollIntoView({ behavior: 'auto', block: 'nearest', inline: 'nearest' });
                    }
                }, 150); // Delay to allow keyboard animation
            });
        }

        function setupRightToLeftInput(question, requiredDigits) {
            const answerDisplay = document.getElementById('answerDisplay');
            const input = document.getElementById('answerInput');
            const multidigitTable = document.getElementById('multidigitTable');
            
            input.classList.add('hidden');
            answerDisplay.classList.add('hidden');
            multidigitTable.classList.remove('hidden');
            
            // Clear previous table content
            multidigitTable.innerHTML = '';
            
            // Convert numbers to digit arrays
            const firstNumStr = question.first.toString();
            const secondNumStr = question.second.toString();
            const firstDigits = firstNumStr.split('');
            const secondDigits = secondNumStr.split('');
            const operation = currentSession.operation === 'addition' ? '+' : 
                            currentSession.operation === 'subtraction' ? '-' :
                            currentSession.operation === 'multiplication' ? '×' : '÷';
            
            const numCols = 6;
            
            // Right-align by padding left with empty strings
            const padFirst = new Array(numCols - firstDigits.length).fill('');
            const padSecond = new Array(numCols - secondDigits.length).fill('');
            const firstRowDigits = [...padFirst, ...firstDigits];
            const secondRowDigits = [...padSecond, ...secondDigits];
            
            // Create 4 rows
            const rows = [];
            const answerCells = [];
            
            // Row 1: First number (right-aligned)
            const row1 = document.createElement('tr');
            for (let i = 0; i < numCols; i++) {
                const cell = document.createElement('td');
                cell.textContent = firstRowDigits[i] || '';
                row1.appendChild(cell);
            }
            rows.push(row1);
            
            // Row 2: Operation + Second number
            // Find rightmost non-empty position for operation
            let opPosition = numCols - secondDigits.length - 1;
            if (opPosition < 0) opPosition = 0;
            
            const row2 = document.createElement('tr');
            for (let i = 0; i < numCols; i++) {
                const cell = document.createElement('td');
                if (i === opPosition) {
                    cell.textContent = operation;
                    cell.className = 'operation-cell';
                } else {
                    // Adjust index for second number digits
                    const digitIndex = i - opPosition - 1;
                    if (digitIndex >= 0 && digitIndex < secondDigits.length) {
                        cell.textContent = secondDigits[digitIndex];
                    } else {
                        cell.textContent = '';
                    }
                }
                row2.appendChild(cell);
            }
            rows.push(row2);
            
            // Row 3: Answer input cells (right-aligned, rightmost cell is last in array)
            const row3 = document.createElement('tr');
            const enteredDigits = [];
            // Store cells from left to right, but input goes right to left
            for (let i = 0; i < numCols; i++) {
                const cell = document.createElement('td');
                cell.className = 'input-cell';
                cell.textContent = ''; // No placeholder prompt
                // Make cell focusable - use both tabindex and contenteditable for better mobile support
                cell.setAttribute('tabindex', '0');
                cell.setAttribute('contenteditable', 'false'); // We'll handle input via keydown, not contenteditable
                cell.setAttribute('role', 'textbox'); // For better accessibility
                cell.setAttribute('aria-label', `Answer digit ${i + 1}`);
                cell.dataset.position = i; // Position from left (0 = leftmost, 5 = rightmost)
                // Prevent default contenteditable behavior
                cell.style.userSelect = 'none';
                cell.style.webkitUserSelect = 'none';
                answerCells.push(cell);
                row3.appendChild(cell);
            }
            rows.push(row3);
            
            // Row 4: Correct answer display (initially empty, shown when answer is checked)
            const row4 = document.createElement('tr');
            const answerDisplayCells = [];
            for (let i = 0; i < numCols; i++) {
                const cell = document.createElement('td');
                cell.textContent = '';
                cell.style.borderTop = '3px solid #764ba2';
                cell.style.color = '#dc3545'; // Red color for correct answer
                answerDisplayCells.push(cell);
                row4.appendChild(cell);
            }
            rows.push(row4);
            
            // Add rows to table
            rows.forEach(row => multidigitTable.appendChild(row));
            
            // Store data for handlers
            const isDivision = currentSession.operation === 'division';
            multidigitTable._question = question;
            multidigitTable._answerCells = answerCells;
            multidigitTable._answerDisplayCells = answerDisplayCells;
            multidigitTable._requiredDigits = requiredDigits;
            multidigitTable._enteredDigits = [];
            multidigitTable._currentPosition = isDivision ? 4 : numCols - 1; // Division starts at 5th cell (index 4), others start at rightmost
            
            // Handle keypress for right-to-left entry (or left-to-right for division)
            const handleKeyPress = (e) => {
                const target = e.target;
                if (!target.classList.contains('input-cell')) return;
                
                // Prevent any input that's not a digit or control key
                if (e.key >= '0' && e.key <= '9') {
                    e.preventDefault();
                    e.stopPropagation();
                    const enteredCount = multidigitTable._enteredDigits.length;
                    if (enteredCount < requiredDigits && enteredCount < numCols) {
                        let position;
                        if (isDivision) {
                            // Division: add digit from left to right, starting at position 4
                            position = 4 + enteredCount;
                        } else {
                            // Other operations: add digit from right to left (rightmost position is numCols - 1)
                            position = numCols - 1 - enteredCount;
                        }
                        const cell = answerCells[position];
                        cell.textContent = e.key;
                        cell.className = 'input-cell entered';
                        multidigitTable._enteredDigits.push(e.key);
                        multidigitTable._currentPosition = position;
                        
                        // Check if all digits entered
                        if (multidigitTable._enteredDigits.length === requiredDigits) {
                            let userAnswer;
                            if (isDivision) {
                                // Division: digits entered left-to-right, no reversal needed
                                userAnswer = parseInt(multidigitTable._enteredDigits.join(''));
                            } else {
                                // Other operations: reverse the array since digits were entered right-to-left
                                const reversedDigits = [...multidigitTable._enteredDigits].reverse();
                                userAnswer = parseInt(reversedDigits.join(''));
                            }
                            setTimeout(() => {
                                checkAnswer(question, userAnswer);
                            }, 100);
                        } else {
                            // Move focus to next cell
                            let nextPosition;
                            if (isDivision) {
                                // Division: move right
                                nextPosition = position + 1;
                                if (nextPosition < numCols) {
                                    setTimeout(() => {
                                        answerCells[nextPosition].focus();
                                    }, 10);
                                }
                            } else {
                                // Other operations: move left
                                if (position > 0) {
                                    setTimeout(() => {
                                        answerCells[position - 1].focus();
                                    }, 10);
                                }
                            }
                        }
                    }
                } else if (e.key === 'Backspace' || e.key === 'Delete') {
                    e.preventDefault();
                    e.stopPropagation();
                    const enteredCount = multidigitTable._enteredDigits.length;
                    if (enteredCount > 0) {
                        let position;
                        if (isDivision) {
                            // Division: remove last entered digit (from rightmost entered position)
                            position = 4 + enteredCount - 1;
                        } else {
                            // Other operations: remove digit from right to left
                            position = numCols - enteredCount;
                        }
                        const cell = answerCells[position];
                        cell.textContent = '';
                        cell.className = 'input-cell';
                        multidigitTable._enteredDigits.pop();
                        // Move focus to the cell we just cleared
                        setTimeout(() => {
                            cell.focus();
                        }, 10);
                    }
                } else if (e.key === 'ArrowLeft' && multidigitTable._currentPosition > 0) {
                    e.preventDefault();
                    e.stopPropagation();
                    multidigitTable._currentPosition--;
                    answerCells[multidigitTable._currentPosition].focus();
                } else if (e.key === 'ArrowRight' && multidigitTable._currentPosition < numCols - 1) {
                    e.preventDefault();
                    e.stopPropagation();
                    multidigitTable._currentPosition++;
                    answerCells[multidigitTable._currentPosition].focus();
                } else if (e.key.length === 1) {
                    // Block any other single character input
                    e.preventDefault();
                    e.stopPropagation();
                }
            };
            
            // Handle touch/click events for mobile
            const handleClick = function() {
                const position = parseInt(this.dataset.position);
                multidigitTable._currentPosition = position;
                // Use requestAnimationFrame for better focus timing
                requestAnimationFrame(() => {
                    this.focus();
                    // On mobile, ensure keyboard appears
                    if (window.innerWidth <= 768) {
                        // Force focus again after a short delay to ensure keyboard appears
                        setTimeout(() => {
                            this.focus();
                        }, 100);
                    }
                });
            };
            
            // Handle focus event to ensure proper scrolling
            const handleFocus = function() {
                // Use 'nearest' to prevent excessive scrolling, let sticky positioning keep question visible
                setTimeout(() => {
                    const rect = this.getBoundingClientRect();
                    const viewportHeight = window.innerHeight;
                    // Only scroll if cell is mostly hidden by keyboard
                    if (rect.bottom > viewportHeight * 0.85) {
                        this.scrollIntoView({ behavior: 'auto', block: 'nearest', inline: 'nearest' });
                    }
                }, 200); // Delay to allow keyboard animation
            };
            
            // Add event listeners to all answer cells BEFORE focusing
            answerCells.forEach(cell => {
                cell.addEventListener('keydown', handleKeyPress);
                cell.addEventListener('click', handleClick);
                cell.addEventListener('touchstart', handleClick, { passive: true });
                cell.addEventListener('focus', handleFocus);
                // Prevent default behaviors that might interfere
                cell.addEventListener('paste', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
                cell.addEventListener('input', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
            });
            
            // Focus on initial cell after DOM update and all event listeners are attached
            // Division: 5th cell (index 4), Others: rightmost cell
            // Use multiple attempts to ensure focus works on mobile
            const focusInitialCell = () => {
                const initialCell = answerCells[multidigitTable._currentPosition];
                if (initialCell) {
                    // First attempt
                    initialCell.focus();
                    // Second attempt after a delay for mobile devices
                    setTimeout(() => {
                        initialCell.focus();
                        // Third attempt if on mobile (for stubborn devices)
                        if (window.innerWidth <= 768) {
                            setTimeout(() => {
                                initialCell.focus();
                                // Scroll the cell into view to ensure it's visible
                                initialCell.scrollIntoView({ behavior: 'auto', block: 'nearest', inline: 'nearest' });
                            }, 300);
                        }
                    }, 150);
                }
            };
            
            // Wait for DOM to fully render before focusing
            requestAnimationFrame(() => {
                setTimeout(focusInitialCell, 100);
            });
        }

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            
            const operation = currentSession.operation;
            const variantConfig = variants[operation][currentSession.variant];
            const timerEl = document.getElementById('timer');
            
            // Timer is always hidden, but we still track time
            timerEl.style.display = 'none';
            timerEl.classList.add('hidden');
            
            // Check if there's no time limit for this variant
            if (variantConfig.noTimeLimit) {
                // Still track time even though timer is hidden
                timeElapsed = 0;
                questionStartTime = Date.now();
                timerInterval = setInterval(() => {
                    timeElapsed += 0.1;
                }, 100);
                return;
            }
            
            // For variants with time limits, track time but don't display timer
            timeElapsed = 0;
            questionStartTime = Date.now();
            timerEl.textContent = 'Time: 0.0s';
            timerEl.classList.remove('warning');
            
            timerInterval = setInterval(() => {
                timeElapsed += 0.1;
                const roundedTime = Math.round(timeElapsed * 10) / 10;
                
                // Check time limit without displaying timer
                if (roundedTime >= 6) {
                    clearInterval(timerInterval);
                    // Timeout - show correct answer
                    const question = currentSession.questions[currentSession.questionIndex];
                    checkAnswer(question, null);
                }
            }, 100);
        }

        function speakQuestionAndAnswer(question, correctAnswer) {
            return new Promise((resolve) => {
                if ('speechSynthesis' in window) {
                    const operation = currentSession.operation;
                    let opWord = 'plus';
                    if (operation === 'subtraction') opWord = 'minus';
                    else if (operation === 'multiplication') opWord = 'times';
                    else if (operation === 'division') opWord = 'divided by';

                    const text = `${question.first} ${opWord} ${question.second} equals ${correctAnswer}`;
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 0.9;
                    utterance.pitch = 1;
                    
                    utterance.onend = () => {
                        resolve();
                    };
                    
                    utterance.onerror = () => {
                        resolve(); // Resolve even on error to continue
                    };
                    
                    speechSynthesis.speak(utterance);
                } else {
                    resolve(); // If speech not supported, resolve immediately
                }
            });
        }

        function checkAnswer(question, userAnswer) {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            const timeTaken = Math.round(timeElapsed * 10) / 10;
            const correctAnswer = question.answer;
            const isCorrect = userAnswer !== null && userAnswer === correctAnswer;

            currentSession.totalTime += timeTaken;

            if (isCorrect) {
                currentSession.correctCount++;
            } else {
                currentSession.wrongCount++;
                // For multi-digit variants, show answer in table row 4, otherwise in line4
                const multidigitTable = document.getElementById('multidigitTable');
                if (multidigitTable && !multidigitTable.classList.contains('hidden')) {
                    // Show correct answer in row 4 of table (right-aligned)
                    const answerDisplayCells = multidigitTable._answerDisplayCells || [];
                    const answerStr = correctAnswer.toString();
                    const answerDigits = answerStr.split('');
                    const numCols = 6;
                    // Right-align the answer
                    const padCount = numCols - answerDigits.length;
                    for (let i = 0; i < numCols; i++) {
                        const cell = answerDisplayCells[i];
                        if (i < padCount) {
                            cell.textContent = '';
                        } else {
                            cell.textContent = answerDigits[i - padCount];
                        }
                    }
                } else {
                    // Standard variant: show in line4 text element
                    document.getElementById('line4').textContent = `Correct Answer: ${correctAnswer}`;
                }
            }

            // Record result
            const operation = currentSession.operation;
            let opSymbol = '+';
            if (operation === 'subtraction') opSymbol = '-';
            else if (operation === 'multiplication') opSymbol = '×';
            else if (operation === 'division') opSymbol = '÷';

            currentSession.results.push({
                question: `${question.first} ${opSymbol} ${question.second}`,
                userAnswer: userAnswer !== null ? userAnswer : 'No Answer',
                correctAnswer: correctAnswer,
                time: timeTaken,
                isCorrect: isCorrect
            });

            // Disable input (both normal, right-to-left display, and table)
            const input = document.getElementById('answerInput');
            const answerDisplay = document.getElementById('answerDisplay');
            const multidigitTable = document.getElementById('multidigitTable');
            if (input && !input.classList.contains('hidden')) {
                input.disabled = true;
            }
            if (answerDisplay && !answerDisplay.classList.contains('hidden')) {
                answerDisplay.setAttribute('tabindex', '-1');
                answerDisplay.style.pointerEvents = 'none';
            }
            if (multidigitTable && !multidigitTable.classList.contains('hidden')) {
                const answerCells = multidigitTable._answerCells || [];
                answerCells.forEach(cell => {
                    cell.setAttribute('tabindex', '-1');
                    cell.style.pointerEvents = 'none';
                });
            }

            // If wrong or no answer, speak and wait for speech to complete (skip for multi-digit variants)
            const variantConfig = variants[operation][currentSession.variant];
            if (!isCorrect && variantConfig.rightToLeft) {
                // Multi-digit variant: answer already shown in row 4, wait 6 seconds, then move to next question
                setTimeout(() => {
                    currentSession.questionIndex++;
                    askNextQuestion();
                }, 6000);
            } else if (!isCorrect) {
                // Standard variant: speak and wait for speech to complete
                speakQuestionAndAnswer(question, correctAnswer).then(() => {
                    setTimeout(() => {
                        currentSession.questionIndex++;
                        askNextQuestion();
                    }, 500);
                });
            } else {
                // If correct, make input light green for single-digit questions (not multi-digit)
                if (!variantConfig.rightToLeft && input && !input.classList.contains('hidden')) {
                    input.style.backgroundColor = '#d4edda'; // Light green color (same as dashboard)
                    input.style.transition = 'background-color 0.3s ease';
                }
                // Wait 0.25 seconds then move to next question (green will persist during this time)
                setTimeout(() => {
                    currentSession.questionIndex++;
                    askNextQuestion();
                }, 250);
            }
        }

        function showTerminationModal() {
            document.getElementById('modal').style.display = 'flex';
        }

        function continueSession() {
            console.log('▶️ continueSession() called');
            const modal = document.getElementById('modal');
            if (modal) {
                modal.style.display = 'none';
                console.log('✅ Modal closed');
            }
            // Increment questionIndex to move past question 50, then continue
            currentSession.questionIndex++;
            console.log('✅ Question index incremented to:', currentSession.questionIndex);
            askNextQuestion();
        }

        function endSession() {
            console.log('🛑 endSession() called');
            const modal = document.getElementById('modal');
            if (modal) {
                modal.style.display = 'none';
                console.log('✅ Modal closed');
            }
            
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            const questionSection = document.getElementById('questionSection');
            const summarySection = document.getElementById('summarySection');
            
            if (questionSection) {
                questionSection.classList.add('hidden');
                console.log('✅ Question section hidden');
            } else {
                console.error('❌ questionSection element not found');
            }
            
            if (summarySection) {
                summarySection.classList.remove('hidden');
                console.log('✅ Summary section shown');
            } else {
                console.error('❌ summarySection element not found');
            }
            
            showSummary();
        }

        // Make functions globally accessible for onclick handlers
        window.continueSession = continueSession;

        function showSummary() {
            console.log('📊 showSummary() called');
            const session = currentSession;
            const totalQuestions = session.correctCount + session.wrongCount;
            console.log('📊 Session stats:', {
                correct: session.correctCount,
                wrong: session.wrongCount,
                total: totalQuestions,
                results: session.results.length
            });
            const wrongPercentage = totalQuestions > 0 ? (session.wrongCount / totalQuestions) * 100 : 0;
            const totalTime = Math.round(session.totalTime * 10) / 10;
            const avgTime = session.correctCount > 0 ? Math.round((session.totalTime / session.correctCount) * 10) / 10 : 0;

            const variantName = variants[session.operation][session.variant].name;
            const operationName = session.operation.charAt(0).toUpperCase() + session.operation.slice(1);
            const statsHTML = `
                <p><strong>Operation:</strong> ${operationName}</p>
                <p><strong>Variant:</strong> ${variantName}</p>
                <p><strong>Total Questions:</strong> ${totalQuestions}</p>
                <p><strong>Correct Answers:</strong> ${session.correctCount}</p>
                <p><strong>Wrong Answers:</strong> ${session.wrongCount}</p>
                <p><strong>Total Time:</strong> ${totalTime} seconds</p>
                <p><strong>Average Time per Correct Sum:</strong> ${avgTime} seconds</p>
            `;

            document.getElementById('summaryStats').innerHTML = statsHTML;

            // Check if this is a multi-digit variant
            const variantConfig = variants[session.operation][session.variant];
            const isMultiDigit = variantConfig.rightToLeft;
            
            // Pass criteria: 
            // - Multi-digit variants: 100% correct (no time limit)
            // - Standard variants: wrong ≤ 10% AND average time ≤ 6 seconds
            let passed;
            if (isMultiDigit) {
                passed = session.wrongCount === 0; // 100% correct, no time limit
            } else {
                passed = wrongPercentage <= 10 && avgTime <= 6;
            }
            
            const passFailEl = document.getElementById('passFail');
            passFailEl.textContent = passed ? 'PASS' : 'FAIL';
            passFailEl.className = 'pass-fail ' + (passed ? 'pass' : 'fail');
            
            // Store pass/fail result in session for saving to database
            currentSession.passed = passed;

            // Show question details
            let detailsHTML = '<h3 style="margin-top: 20px; margin-bottom: 10px;">Question Details:</h3>';
            session.results.forEach((result, index) => {
                const itemClass = result.isCorrect ? 'correct' : 'wrong';
                detailsHTML += `
                    <div class="question-item ${itemClass}">
                        <strong>${result.question} = ${result.userAnswer}</strong>
                        ${!result.isCorrect ? `<br>Correct Answer: ${result.correctAnswer}` : ''}
                        <br><small>Time: ${result.time}s | ${result.isCorrect ? 'Correct' : 'Wrong'}</small>
                    </div>
                `;
            });

            document.getElementById('questionDetails').innerHTML = detailsHTML;
        }

        function resetSession() {
            // Go back to dashboard - does NOT log out the user
            document.getElementById('summarySection').classList.add('hidden');
            // Show dashboard if logged in (preserve session)
            if (currentUser) {
                const dashboardSection = document.getElementById('dashboardSection');
                dashboardSection.classList.remove('hidden');
                dashboardSection.style.display = 'block';
                console.log('🔄 Dashboard shown, refreshing variants...');
                
                // Always refresh passed/failed variants when returning to dashboard
                // This ensures the dashboard shows the latest status
                fetchPassedVariants()
                    .catch(err => {
                        console.warn('⚠️ Could not fetch passed variants:', err);
                        return Promise.resolve(); // Continue even if fetch fails
                    })
                    .then(() => {
                        return fetchFailedVariants().catch(err => {
                            console.warn('⚠️ Could not fetch failed variants:', err);
                            return Promise.resolve(); // Continue even if fetch fails
                        });
                    })
                    .then(() => {
                        console.log('✅ Variants refreshed, updating dashboard...');
                        // Update operation completion status (green cards)
                        updateOperationCompletionStatus();
                        
                        // Always refresh variant cards if an operation is selected
                        // This ensures passed/failed status is shown
                        if (selectedOperation) {
                            console.log('🔄 Refreshing variant cards for:', selectedOperation);
                            loadVariantsForOperation(selectedOperation);
                        } else {
                            console.log('ℹ️ No operation selected - variant cards will update when operation is selected');
                        }
                    });
            } else {
                document.getElementById('dashboardSection').classList.add('hidden');
            }
            document.getElementById('answerInput').disabled = false;
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            // Note: This function does NOT call signOut() or handleLogout() - user remains logged in
        }

        // ============================================================================
        // SUPABASE AUTHENTICATION & DATABASE
        // ============================================================================
        // Supabase configuration - Replace these with your Supabase project credentials
        // Get these from: https://app.supabase.com → Your Project → Settings → API
        const SUPABASE_URL = 'https://hgromnervuwqmskdenmb.supabase.co'; // e.g., https://xxxxxxxxxxxxx.supabase.co
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imhncm9tbmVydnV3cW1za2Rlbm1iIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjgwNTExMDgsImV4cCI6MjA4MzYyNzEwOH0.AYWM-6xGhVWnn61ctxj6fClW7KLEp98dlmrd3e5IqJ8'; // e.g., eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
        
        // Site URL for email redirects - Update this with your Netlify site URL
        // IMPORTANT: Password reset emails should always redirect to your production URL (Netlify)
        // Also update Supabase Dashboard → Authentication → URL Configuration:
        //   1. Set "Site URL" to your Netlify URL (e.g., https://premagrawal-maths.netlify.app)
        //   2. Add to "Redirect URLs": https://premagrawal-maths.netlify.app/**
        const PRODUCTION_URL = 'https://premagrawal-maths.netlify.app';
        const SITE_URL = window.location.origin; // Current URL (for local testing)
        
        // For password reset, always use production URL (emails should go to live site, not localhost)
        const PASSWORD_RESET_REDIRECT_URL = PRODUCTION_URL;
        
        // Initialize Supabase client
        let supabase = null;
        let currentUser = null;
        let currentUserProfile = null; // Stores user profile with email and other fields
        let isLoginMode = true;

        // Handle email confirmation callback
        function handleEmailConfirmation() {
            // Check if this is an email confirmation or password reset callback
            const hashParams = new URLSearchParams(window.location.hash.substring(1));
            const accessToken = hashParams.get('access_token');
            const type = hashParams.get('type');
            
            if (type === 'signup' && accessToken) {
                // User clicked email confirmation link
                console.log('✅ Email confirmation detected - Supabase will process this automatically');
                // Supabase will automatically process the session from URL hash
                // when detectSessionInUrl: true is set and getSession() is called
            } else if (type === 'recovery' && accessToken) {
                // User clicked password reset link in email
                console.log('✅ Password reset confirmation detected');
                // Show forgot password modal with reset form
                showForgotPasswordModal();
            }
        }
        
        // Clean up URL hash after email confirmation or password reset
        function cleanupEmailConfirmationUrl() {
            if (window.location.hash.includes('access_token') || window.location.hash.includes('type=signup') || window.location.hash.includes('type=recovery')) {
                // Clean up the URL hash after processing
                setTimeout(() => {
                    window.history.replaceState(null, '', window.location.pathname + window.location.search);
                }, 1000);
            }
        }
        
        // Initialize Supabase
        function initSupabase() {
            // Check if Supabase library is loaded
            if (!window.supabase || !window.supabase.createClient) {
                console.error('Supabase library not loaded. Please check the script tag.');
                return;
            }
            
            // Validate credentials
            if (!SUPABASE_URL || SUPABASE_URL === 'YOUR_SUPABASE_URL' || 
                !SUPABASE_ANON_KEY || SUPABASE_ANON_KEY === 'YOUR_SUPABASE_ANON_KEY') {
                console.warn('⚠️ Supabase credentials not configured.');
                console.warn('Please add your Supabase URL and Anon Key in index.html (lines 1754-1755)');
                console.warn('Get them from: https://app.supabase.com → Your Project → Settings → API');
                return;
            }
            
            // Validate URL format
            if (!SUPABASE_URL.startsWith('https://') || !SUPABASE_URL.includes('.supabase.co')) {
                console.error('❌ Invalid Supabase URL format. Should be: https://xxxxx.supabase.co');
                return;
            }
            
            // Validate key format
            if (!SUPABASE_ANON_KEY.startsWith('eyJ')) {
                console.error('❌ Invalid Supabase Anon Key format. Should start with "eyJ"');
                return;
            }
            
            try {
                // Create Supabase client
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
                    auth: {
                        persistSession: true,
                        autoRefreshToken: true,
                        detectSessionInUrl: true
                    }
                });
                
                console.log('✅ Supabase client initialized successfully');
                
                // Test connection by checking for existing session
                supabase.auth.getSession().then(({ data: { session }, error }) => {
                    if (error) {
                        console.error('Error getting session:', error);
                        return;
                    }
                    
            // Check if this is a password reset link (before checking for existing session)
            // Check both hash and query parameters
            let type = null;
            let accessToken = null;
            
            if (window.location.hash) {
                const hashParams = new URLSearchParams(window.location.hash.substring(1));
                type = hashParams.get('type') || type;
                accessToken = hashParams.get('access_token') || accessToken;
            }
            
            if (window.location.search) {
                const queryParams = new URLSearchParams(window.location.search);
                type = queryParams.get('type') || type;
                accessToken = queryParams.get('access_token') || accessToken;
            }
            
            if (type === 'recovery' && accessToken) {
                // User clicked password reset link - Supabase should have processed the session
                // Wait a moment for Supabase to fully process the session, then show modal
                setTimeout(() => {
                    showForgotPasswordModal();
                }, 500);
                return; // Don't process as normal session
            }
            
            // Also check if we flagged to show password reset from page load
            if (window._showPasswordReset || window._passwordResetDetected) {
                delete window._showPasswordReset;
                delete window._passwordResetDetected;
                setTimeout(() => {
                    showForgotPasswordModal();
                }, 500);
                return;
            }
                    
                    if (session) {
                        currentUser = session.user;
                        console.log('🔄 Page loaded: Found existing session from previous login');
                        console.log('   User ID:', currentUser.id);
                        console.log('   Email:', currentUser.email);
                        console.log('   (Session was stored in browser - you were already logged in)');
                        // Fetch user profile
                        fetchUserProfile().then(async profile => {
                            currentUserProfile = profile;
                            await updateAuthUI();
                            // Ensure dashboard is visible
                            const dashboardSection = document.getElementById('dashboardSection');
                            if (dashboardSection && currentUser) {
                                dashboardSection.classList.remove('hidden');
                            }
                            // Clear variants when loading existing session
                            document.getElementById('variantsContainer').innerHTML = '';
                            selectedOperation = null;
                            document.querySelectorAll('.operation-card').forEach(card => {
                                card.classList.remove('selected');
                            });
                            console.log('✅ Existing session restored for user:', currentUser.email);
                        });
                    } else {
                        console.log('ℹ️ No existing session found - user needs to log in');
                        // Show login form when no session
                        currentUser = null;
                        updateAuthUI();
                    }
                });
                
                // Listen for auth changes
                supabase.auth.onAuthStateChange(async (event, session) => {
                    console.log('Auth state changed:', event);
                    
                    if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
                        currentUser = session?.user || null;
                        
                        // Distinguish between auto-restored session and manual login
                        if (event === 'SIGNED_IN') {
                            // Check if this is an initial session restore (page load) or a new login
                            const isInitialLoad = !currentUserProfile && document.getElementById('inlineLoginBtn')?.textContent === 'Log In';
                            if (isInitialLoad) {
                                console.log('🔄 SIGNED_IN: Auto-restored session from previous login (stored in browser)');
                            } else {
                                console.log('🔐 SIGNED_IN: User just logged in manually');
                            }
                        } else {
                            console.log('🔄 TOKEN_REFRESHED: Session token refreshed automatically');
                        }
                        console.log('🔐 Auth state: SIGNED_IN, currentUser:', currentUser ? 'exists' : 'null');
                        
                        // Update UI when signed in
                        if (event === 'SIGNED_IN') {
                            console.log('🔐 SIGNED_IN event - updating UI (user is now logged in)');
                            // Only update UI if we have a currentUser
                            if (!currentUser) {
                                console.warn('⚠️ SIGNED_IN event but no currentUser - skipping UI update');
                                return;
                            }
                            try {
                                await updateAuthUI();
                                // Force dashboard to show after a small delay to ensure DOM is ready
                                setTimeout(() => {
                                    const dashboardSection = document.getElementById('dashboardSection');
                                    if (dashboardSection && currentUser) {
                                        dashboardSection.classList.remove('hidden');
                                        console.log('✅ Dashboard forced to show');
                                    }
                                }, 100);
                                cleanupEmailConfirmationUrl();
                            } catch (err) {
                                console.error('❌ Error updating UI after SIGNED_IN:', err);
                            }
                        }
                    } else if (event === 'SIGNED_OUT') {
                        currentUser = null;
                        currentUserProfile = null;
                        updateAuthUI();
                        console.log('✅ User logged out');
                    } else if (event === 'USER_UPDATED') {
                        currentUser = session?.user || null;
                        if (currentUser) {
                            currentUserProfile = await fetchUserProfile();
                        }
                        updateAuthUI();
                    }
                });
                
                // Test database connection
                testDatabaseConnection();
                
            } catch (error) {
                console.error('❌ Error initializing Supabase:', error);
                console.error('Error details:', error.message);
            }
        }
        
        // Test database connection
        async function testDatabaseConnection() {
            if (!supabase) return;
            
            try {
                // Try a simple query to test connection
                const { data, error } = await supabase
                    .from('user_scores')
                    .select('count', { count: 'exact', head: true });
                
                if (error) {
                    // If table doesn't exist, that's okay - just log it
                    if (error.code === 'PGRST116' || error.message.includes('relation') || error.message.includes('does not exist')) {
                        console.warn('⚠️ user_scores table not found. Please run the SQL schema from supabase-schema.sql');
                    } else {
                        console.error('❌ Database connection test failed:', error.message);
                    }
                } else {
                    console.log('✅ Database connection successful');
                }
            } catch (error) {
                console.error('❌ Error testing database connection:', error);
            }
        }

        // Fetch user profile from user_profiles table
        async function fetchUserProfile() {
            // Prevent multiple simultaneous fetches
            if (isFetchingProfile) {
                console.log('⚠️ fetchUserProfile: Already fetching, skipping duplicate call');
                return currentUserProfile; // Return existing or null
            }
            
            if (!currentUser || !supabase) {
                console.log('⚠️ fetchUserProfile: No currentUser or supabase - user not logged in yet');
                return null;
            }
            
            // Check if we already have the profile
            if (currentUserProfile) {
                console.log('ℹ️ fetchUserProfile: Profile already cached');
                return currentUserProfile;
            }
            
            isFetchingProfile = true;
            console.log('📥 fetchUserProfile: Starting query for user_id:', currentUser.id);
            
            try {
                // Add timeout to prevent hanging
                const queryPromise = supabase
                    .from('user_profiles')
                    .select('*')
                    .eq('user_id', currentUser.id)
                    .single();
                
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Profile fetch timeout after 3 seconds')), 3000)
                );
                
                const { data, error } = await Promise.race([queryPromise, timeoutPromise]);
                
                isFetchingProfile = false;
                
                if (error) {
                    // If profile doesn't exist, that's okay - user might not have completed signup
                    if (error.code === 'PGRST116' || error.message?.includes('timeout')) {
                        if (error.code === 'PGRST116') {
                            console.log('ℹ️ User profile not found in database (user may need to complete signup)');
                        } else {
                            console.warn('⚠️ Profile fetch timed out - this is non-critical, continuing without profile');
                        }
                    } else {
                        console.error('❌ Error fetching user profile:', error);
                    }
                    return null;
                }
                
                // Log the full profile data to debug
                if (data) {
                    console.log('✅ fetchUserProfile: Success, full profile data:', JSON.stringify(data, null, 2));
                } else {
                    console.warn('⚠️ fetchUserProfile: Query succeeded but returned null data');
                }
                return data;
            } catch (error) {
                isFetchingProfile = false;
                // Don't log timeout errors as critical - they're expected if table doesn't exist or RLS blocks
                if (error.message?.includes('timeout')) {
                    console.warn('⚠️ Profile fetch timed out - this is non-critical, continuing without profile');
                } else {
                    console.error('❌ Error fetching user profile (catch):', error);
                }
                return null;
            }
        }

        // Dashboard state
        let selectedOperation = null;
        let passedVariants = new Set(); // Store passed variant keys (operation_variant)
        let failedVariants = new Set(); // Store failed variant keys (operation_variant) - all attempts failed
        let isFetchingProfile = false; // Prevent multiple simultaneous profile fetches
        
        // Learning sequence for each operation (order students should learn)
        const learningSequence = {
            addition: ['1A0', '1A1', '1A2', '1A3', '1A', '1B', '1C', '1D', '1', '1M1', '1M2'],
            subtraction: ['2A', '2B', '2C', '2D', '2', '2M1', '2M2', '2M3'],
            multiplication: ['3A0', '3A1', '3A2S', '3A2', '3A3S', '3A3', '3A', '3B4S', '3B4', '3B5S', '3B5', '3B6S', '3B6', '3B', '3C7S', '3C7', '3C8S', '3C8', '3C9S', '3C9', '3C', '3', '3M1', '3M2'],
            division: ['4A1', '4A2', '4A3', '4A', '4B4', '4B5', '4B6', '4B', '4C7', '4C8', '4C9', '4C', '4', '4M1', '4M2']
        };

        // Fetch passed variants from user_scores
        async function fetchPassedVariants() {
            if (!currentUser || !supabase) {
                passedVariants.clear();
                return;
            }

            try {
                // Add timeout to prevent hanging
                const queryPromise = supabase
                    .from('user_scores')
                    .select('operation, variant')
                    .eq('user_id', currentUser.id)
                    .eq('passed', true);
                
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Query timeout')), 5000)
                );
                
                let result;
                try {
                    result = await Promise.race([queryPromise, timeoutPromise]);
                } catch (timeoutError) {
                    console.warn('⚠️ Passed variants query timed out, continuing without data');
                    return;
                }
                
                const { data, error } = result || { data: null, error: null };

                if (error) {
                    console.error('Error fetching passed variants:', error);
                    return;
                }

                // Store as "operation_variant" keys
                passedVariants.clear();
                if (data && Array.isArray(data)) {
                    console.log('📥 Processing', data.length, 'passed score records...');
                    data.forEach(score => {
                        if (score.operation && score.variant) {
                            const key = `${score.operation}_${score.variant}`;
                            passedVariants.add(key);
                            console.log('✅ Added passed variant:', key, 'from score:', { operation: score.operation, variant: score.variant, passed: score.passed });
                        } else {
                            console.warn('⚠️ Invalid score record (missing operation or variant):', score);
                        }
                    });
                } else {
                    console.log('ℹ️ No passed score data received (data is null or not an array)');
                }
                console.log('✅ Passed variants Set updated. Total:', passedVariants.size, 'Variants:', Array.from(passedVariants));
            } catch (error) {
                console.error('Error fetching passed variants:', error);
                // Don't throw - just log and continue
            }
        }

        // Update operation card completion status (green if all variants passed)
        function updateOperationCompletionStatus() {
            if (!currentUser) return;

            const operations = ['addition', 'subtraction', 'multiplication', 'division'];
            
            operations.forEach(operation => {
                const opsVariants = variants[operation];
                if (!opsVariants) return;

                const variantKeys = Object.keys(opsVariants);
                const allVariantsPassed = variantKeys.every(variantKey => {
                    const variantKeyFull = `${operation}_${variantKey}`;
                    return passedVariants.has(variantKeyFull);
                });

                // Find the operation card
                const operationCards = document.querySelectorAll('.operation-card');
                operationCards.forEach(card => {
                    const onclickAttr = card.getAttribute('onclick');
                    if (onclickAttr && onclickAttr.includes(`selectOperation('${operation}')`)) {
                        if (allVariantsPassed && variantKeys.length > 0) {
                            card.classList.add('completed');
                            console.log(`✅ Operation ${operation} marked as completed (all variants passed)`);
                        } else {
                            card.classList.remove('completed');
                        }
                    }
                });
            });
        }

        // Fetch variants where all attempts failed
        async function fetchFailedVariants() {
            if (!currentUser || !supabase) {
                failedVariants.clear();
                return;
            }

            try {
                // Get all scores for this user where passed = false
                // These are variants where user attempted but all attempts failed
                // Note: We query for passed=false, but we need to ensure the variant is not also passed
                // So we'll check against passedVariants after it's populated
                
                // Add timeout to prevent hanging
                const queryPromise = supabase
                    .from('user_scores')
                    .select('operation, variant, passed')
                    .eq('user_id', currentUser.id)
                    .eq('passed', false);
                
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Query timeout')), 5000)
                );
                
                let result;
                try {
                    result = await Promise.race([queryPromise, timeoutPromise]);
                } catch (timeoutError) {
                    console.warn('⚠️ Failed variants query timed out, continuing without data');
                    return;
                }
                
                const { data, error } = result || { data: null, error: null };

                if (error) {
                    console.error('Error fetching failed variants:', error);
                    return;
                }

                // Store as "operation_variant" keys
                // Only mark as failed if it's not also in passedVariants (safety check)
                failedVariants.clear();
                if (data && Array.isArray(data)) {
                    console.log('📥 Processing', data.length, 'failed score records...');
                    data.forEach(score => {
                        if (score.operation && score.variant) {
                            const key = `${score.operation}_${score.variant}`;
                            // Only mark as failed if it's not also passed (shouldn't happen, but safety check)
                            if (!passedVariants.has(key)) {
                                failedVariants.add(key);
                                console.log('❌ Added failed variant:', key, 'from score:', { operation: score.operation, variant: score.variant, passed: score.passed });
                            } else {
                                console.log('⚠️ Skipping failed variant', key, '- already in passed variants');
                            }
                        } else {
                            console.warn('⚠️ Invalid score record (missing operation or variant):', score);
                        }
                    });
                } else {
                    console.log('ℹ️ No failed score data received (data is null or not an array)');
                }
                console.log('❌ Failed variants Set updated. Total:', failedVariants.size, 'Variants:', Array.from(failedVariants));
            } catch (error) {
                console.error('Error fetching failed variants:', error);
                // Don't throw - just log and continue
            }
        }

        // Handle inline login
        async function handleInlineLogin(event) {
            if (event) {
                event.preventDefault();
            }
            
            const email = document.getElementById('inlineEmail').value.trim();
            const password = document.getElementById('inlinePassword').value;
            const errorEl = document.getElementById('loginError');
            const loginBtn = document.getElementById('inlineLoginBtn');
            
            errorEl.textContent = '';
            loginBtn.disabled = true;
            loginBtn.textContent = 'Logging in...';
            
            if (!supabase) {
                errorEl.textContent = 'Authentication service not available.';
                loginBtn.disabled = false;
                loginBtn.textContent = 'Log In';
                return false;
            }
            
            if (!email) {
                errorEl.textContent = 'Email is required';
                loginBtn.disabled = false;
                loginBtn.textContent = 'Log In';
                return false;
            }
            
            let loginSuccessful = false;
            try {
                console.log('🔐 Attempting login with email:', email);
                
                const { data, error } = await supabase.auth.signInWithPassword({
                    email: email,
                    password: password
                });
                
                if (error) throw error;
                
                // Update currentUser immediately
                const { data: { user } } = await supabase.auth.getUser();
                currentUser = user;
                console.log('✅ Login successful, currentUser set:', currentUser?.id);
                loginSuccessful = true;
                
                // Reset login button IMMEDIATELY (don't wait for anything)
                if (loginBtn) {
                    loginBtn.disabled = false;
                    loginBtn.textContent = 'Log In';
                    loginBtn.classList.add('hidden');
                    console.log('✅ Login button reset and hidden immediately');
                }
                const logoutBtn = document.getElementById('inlineLogoutBtn');
                if (logoutBtn) {
                    logoutBtn.classList.remove('hidden');
                    console.log('✅ Logout button shown');
                }
                
                // Show success message briefly
                errorEl.textContent = '';
                errorEl.style.color = '#28a745';
                errorEl.textContent = '✅ Login successful!';
                setTimeout(() => {
                    errorEl.textContent = '';
                    errorEl.style.color = '';
                }, 2000);
                
                // Show dashboard immediately
                const dashboardSection = document.getElementById('dashboardSection');
                if (dashboardSection) {
                    dashboardSection.classList.remove('hidden');
                    dashboardSection.style.display = 'block';
                    console.log('✅ Dashboard shown immediately after login');
                }
                
                // Fetch user profile in background (don't block UI)
                fetchUserProfile().then(profile => {
                    currentUserProfile = profile;
                    if (profile) {
                        console.log('✅ User profile fetched in background:', profile);
                        // Update user display with formatted info
                        updateUserDisplay(profile);
                    } else {
                        console.warn('⚠️ User profile not found in database');
                    }
                }).catch(err => {
                    console.warn('⚠️ Could not fetch user profile, continuing anyway:', err);
                });
                
                // Fetch passed and failed variants in background
                // Fetch passed variants first, then failed variants (which depends on passedVariants)
                fetchPassedVariants()
                    .catch(err => {
                        console.warn('⚠️ Could not fetch passed variants:', err);
                    })
                    .then(() => {
                        // After passed variants are loaded, fetch failed variants
                        return fetchFailedVariants().catch(err => {
                            console.warn('⚠️ Could not fetch failed variants:', err);
                        });
                    })
                    .then(() => {
                        updateOperationCompletionStatus();
                    });
                
                return false;
            } catch (err) {
                console.error('❌ Login error:', err);
                errorEl.textContent = err.message || 'Login failed. Please check your credentials.';
                return false;
            } finally {
                // Only reset button if login failed (on success, it's already hidden)
                if (!loginSuccessful && loginBtn) {
                    loginBtn.disabled = false;
                    loginBtn.textContent = 'Log In';
                    console.log('✅ Login button reset in finally block (login failed)');
                } else if (loginSuccessful && loginBtn) {
                    // Double-check button is hidden on success
                    if (!loginBtn.classList.contains('hidden')) {
                        loginBtn.classList.add('hidden');
                        console.log('✅ Login button force-hidden in finally block');
                    }
                }
            }
        }
        
        // Update user display with formatted information
        function updateUserDisplay(profile) {
            const userDisplay = document.getElementById('userDisplay');
            if (!userDisplay) return;
            
            if (profile) {
                const parts = [];
                
                // First name + Last name
                const fullName = [profile.first_name, profile.last_name].filter(Boolean).join(' ');
                if (fullName) parts.push(fullName);
                
                // Class + Section
                if (profile.class && profile.section) {
                    parts.push(`${profile.class}${profile.section}`);
                }
                
                // Roll number
                if (profile.roll_number) {
                    parts.push(profile.roll_number);
                }
                
                if (parts.length > 0) {
                    // Display all in one line with spaces
                    userDisplay.textContent = parts.join(' ');
                    userDisplay.classList.remove('hidden');
                } else {
                    userDisplay.textContent = `Logged in as: ${currentUser?.email || ''}`;
                    userDisplay.classList.remove('hidden');
                }
            } else {
                userDisplay.textContent = `Logged in as: ${currentUser?.email || ''}`;
                userDisplay.classList.remove('hidden');
            }
        }

        // Update authentication UI based on current user state
        async function updateAuthUI() {
            console.log('🔄 updateAuthUI called, currentUser:', currentUser ? 'exists' : 'null');
            const inlineLoginBtn = document.getElementById('inlineLoginBtn');
            const inlineLogoutBtn = document.getElementById('inlineLogoutBtn');
            const inlineEmail = document.getElementById('inlineEmail');
            const inlinePassword = document.getElementById('inlinePassword');
            const userDisplay = document.getElementById('userDisplay');
            const loginError = document.getElementById('loginError');
            const dashboardSection = document.getElementById('dashboardSection');

            if (currentUser && supabase) {
                // Show dashboard FIRST, then fetch data in background
                console.log('🎯 Showing dashboard immediately...');
                if (dashboardSection) {
                    dashboardSection.classList.remove('hidden');
                    dashboardSection.style.display = 'block';
                    console.log('✅ Dashboard shown immediately');
                }
                
                // Then fetch user data (non-blocking)
                try {
                    // Fetch user profile (only if not already cached)
                    if (!currentUserProfile && currentUser) {
                        console.log('📥 Fetching user profile in updateAuthUI...');
                        currentUserProfile = await fetchUserProfile();
                        console.log('✅ User profile fetched:', currentUserProfile ? 'success' : 'not found');
                    } else if (!currentUser) {
                        console.log('⚠️ updateAuthUI: No currentUser, skipping profile fetch');
                    }
                    
                    // Fetch passed and failed variants (sequential to avoid race condition)
                    console.log('📥 Fetching passed variants...');
                    await fetchPassedVariants();
                    console.log('✅ Passed variants fetched, count:', passedVariants.size);
                    console.log('📥 Fetching failed variants...');
                    await fetchFailedVariants();
                    console.log('✅ Failed variants fetched, count:', failedVariants.size);
                    // Update operation completion status (green cards for completed operations)
                    updateOperationCompletionStatus();
                    // Refresh variant cards if an operation is already selected
                    // This ensures passed/failed status is shown immediately
                    if (selectedOperation) {
                        console.log('🔄 Refreshing variant cards for selected operation:', selectedOperation);
                        loadVariantsForOperation(selectedOperation);
                    } else {
                        console.log('ℹ️ No operation selected yet - variant cards will show status when operation is selected');
                    }
                } catch (err) {
                    console.error('❌ Error fetching user data:', err);
                    // Continue anyway - dashboard is already shown
                }
                
                // Update inline login UI - reset button state first
                // CRITICAL: Always reset button state when logged in, even if it's stuck
                if (inlineLoginBtn) {
                    // Force reset button state first
                    inlineLoginBtn.disabled = false;
                    inlineLoginBtn.textContent = 'Log In';
                    // Then hide it
                    inlineLoginBtn.classList.add('hidden');
                    console.log('✅ Login button reset and hidden by updateAuthUI');
                }
                if (inlineLogoutBtn) inlineLogoutBtn.classList.remove('hidden');
                if (inlineEmail) inlineEmail.disabled = true;
                if (inlinePassword) inlinePassword.disabled = true;
                // Hide sign-up link when logged in
                const signupLinkContainer = document.getElementById('signupLinkContainer');
                if (signupLinkContainer) signupLinkContainer.style.display = 'none';
                
                // Hide guest notice when logged in
                const guestNotice = document.getElementById('guestNotice');
                if (guestNotice) {
                    guestNotice.classList.add('hidden');
                }
                
                // Show user info with formatted display
                updateUserDisplay(currentUserProfile);
                if (loginError) loginError.textContent = '';
                
                // Dashboard should already be shown above, but ensure it's visible
                if (dashboardSection && dashboardSection.classList.contains('hidden')) {
                    console.log('🎯 Dashboard was hidden, showing now...');
                    dashboardSection.classList.remove('hidden');
                    dashboardSection.style.display = 'block';
                    console.log('✅ Dashboard shown');
                } else if (dashboardSection) {
                    console.log('✅ Dashboard already visible');
                } else {
                    console.error('❌ dashboardSection element not found!');
                }
                
                // Clear variants when logging in
                const variantsContainer = document.getElementById('variantsContainer');
                if (variantsContainer) {
                    variantsContainer.innerHTML = '';
                }
                // Don't clear selectedOperation immediately - let refresh happen first if needed
                // It will be cleared when user selects a new operation
                // Remove selected class from all operation cards
                document.querySelectorAll('.operation-card').forEach(card => {
                    card.classList.remove('selected');
                });
                // Clear selectedOperation after a short delay to allow refresh to complete
                setTimeout(() => {
                    selectedOperation = null;
                }, 100);
                
                // Ensure operations grid is visible
                const operationsGrid = document.querySelector('.operations-grid');
                if (operationsGrid) {
                    operationsGrid.style.display = 'grid';
                }
            } else {
                // Update inline login UI
                if (inlineLoginBtn) {
                    inlineLoginBtn.classList.remove('hidden');
                    inlineLoginBtn.disabled = false;
                    inlineLoginBtn.textContent = 'Log In';
                }
                if (inlineLogoutBtn) inlineLogoutBtn.classList.add('hidden');
                if (inlineEmail) inlineEmail.disabled = false;
                if (inlinePassword) inlinePassword.disabled = false;
                // Show sign-up link when logged out
                const signupLinkContainer = document.getElementById('signupLinkContainer');
                if (signupLinkContainer) signupLinkContainer.style.display = 'block';
                
                if (userDisplay) {
                    userDisplay.textContent = '';
                    userDisplay.classList.add('hidden');
                }
                
                currentUserProfile = null;
                passedVariants.clear();
                failedVariants.clear();
                
                // Remove all visual indicators from variant cards
                document.querySelectorAll('.variant-card').forEach(card => {
                    card.classList.remove('passed', 'failed');
                });
                
                // Remove completion status from operation cards
                document.querySelectorAll('.operation-card').forEach(card => {
                    card.classList.remove('completed');
                });
                
                // Show dashboard (with login form) when logged out, and show operations too
                if (dashboardSection) {
                    dashboardSection.classList.remove('hidden');
                    dashboardSection.style.display = 'block';
                }
                
                // Show guest notice when logged out
                const guestNotice = document.getElementById('guestNotice');
                if (guestNotice) {
                    guestNotice.classList.remove('hidden');
                }
                
                // Show operations grid when logged out (students can practice without login)
                const operationsGrid = document.querySelector('.operations-grid');
                if (operationsGrid) {
                    operationsGrid.style.display = 'grid';
                }
                
                // Show "Choose an Operation" heading when logged out
                const operationHeading = dashboardSection?.querySelector('h2');
                if (operationHeading && operationHeading.textContent.includes('Choose an Operation')) {
                    operationHeading.style.display = 'block';
                }
                
                // Clear variants container when logged out (will be populated when operation is selected)
                const variantsContainer = document.getElementById('variantsContainer');
                if (variantsContainer) {
                    variantsContainer.innerHTML = '';
                }
                selectedOperation = null;
            }
        }

        // Select operation and show variants below
        function selectOperation(operation) {
            // Remove selected class from all cards
            document.querySelectorAll('.operation-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Add selected class to clicked card (if event is available)
            if (event && event.target) {
                const clickedCard = event.target.closest('.operation-card');
                if (clickedCard) {
                    clickedCard.classList.add('selected');
                }
            }
            
            selectedOperation = operation;
            // Always fetch latest passed/failed variants to ensure dashboard is up-to-date
            // This ensures the dashboard always shows current status for all user types
            if (currentUser && supabase) {
                console.log('📥 Fetching latest passed/failed variants for dashboard update...');
                fetchPassedVariants()
                    .then(() => {
                        console.log('✅ Passed variants fetched, count:', passedVariants.size);
                        return fetchFailedVariants();
                    })
                    .then(() => {
                        console.log('✅ Failed variants fetched, count:', failedVariants.size);
                        updateOperationCompletionStatus();
                        loadVariantsForOperation(operation);
                    })
                    .catch(err => {
                        console.warn('⚠️ Error fetching variants, loading with cached data:', err);
                        // Load anyway with whatever data we have
                        loadVariantsForOperation(operation);
                    });
            } else {
                // Not logged in, just show variants without status
                loadVariantsForOperation(operation);
            }
        }

        // Load variants for selected operation
        async function loadVariantsForOperation(operation) {
            const container = document.getElementById('variantsContainer');
            if (!container) {
                console.error('variantsContainer not found');
                return;
            }
            
            container.innerHTML = '<p style="text-align: center; color: #666;">Loading variants...</p>';

            // Get variants for this operation
            const opsVariants = variants[operation];
            if (!opsVariants) {
                container.innerHTML = '<p style="text-align: center; color: #dc3545;">No variants found for this operation.</p>';
                return;
            }

            // Get learning sequence for this operation
            const sequence = learningSequence[operation] || [];
            console.log('📚 Learning sequence for', operation, ':', sequence);
            console.log('✅ Passed variants Set:', Array.from(passedVariants));
            console.log('❌ Failed variants Set:', Array.from(failedVariants));
            console.log('📊 Passed count:', passedVariants.size, 'Failed count:', failedVariants.size);

            // Sort variants by learning sequence
            const variantKeys = Object.keys(opsVariants);
            const sortedKeys = variantKeys.sort((a, b) => {
                const indexA = sequence.indexOf(a);
                const indexB = sequence.indexOf(b);
                
                // If both in sequence, sort by sequence order
                if (indexA !== -1 && indexB !== -1) {
                    return indexA - indexB;
                }
                // If only one in sequence, prioritize it
                if (indexA !== -1) return -1;
                if (indexB !== -1) return 1;
                // If neither in sequence, maintain original order
                return 0;
            });

            container.innerHTML = '';
            
                sortedKeys.forEach(variantKey => {
                const variant = opsVariants[variantKey];
                const variantKeyFull = `${operation}_${variantKey}`;
                const isPassed = passedVariants.has(variantKeyFull);
                const isFailed = failedVariants.has(variantKeyFull);
                
                // Debug logging for passed/failed variants
                console.log(`🔍 Checking variant ${variantKeyFull}: passed=${isPassed}, failed=${isFailed}`);
                if (isPassed) {
                    console.log(`✅ Variant ${variantKeyFull} is PASSED - will show green`);
                } else if (isFailed) {
                    console.log(`❌ Variant ${variantKeyFull} is FAILED - will show red`);
                } else {
                    console.log(`⚪ Variant ${variantKeyFull} is NOT STARTED - will show default`);
                }
                
                const card = document.createElement('div');
                let cardClass = 'variant-card';
                if (isPassed) {
                    cardClass += ' passed';
                } else if (isFailed) {
                    cardClass += ' failed';
                }
                card.className = cardClass;
                card.onclick = () => launchVariant(operation, variantKey);
                
                let statusText = 'Not started';
                if (isPassed) {
                    statusText = '✓ Passed';
                } else if (isFailed) {
                    statusText = '✗ All attempts failed';
                }
                
                card.innerHTML = `
                    <div class="variant-name">${variant.name}</div>
                    <div class="variant-status">${statusText}</div>
                `;
                
                container.appendChild(card);
            });
            
            console.log(`✅ Loaded ${sortedKeys.length} variants for ${operation}`);
        }

        // Launch variant from dashboard
        function launchVariant(operation, variant) {
            // Hide dashboard, show question section
            document.getElementById('dashboardSection').classList.add('hidden');
            const variantsContainer = document.getElementById('variantsContainer');
            if (variantsContainer) {
                variantsContainer.innerHTML = '';
            }
            
            // Start the session with the selected operation and variant
            startSession(operation, variant);
        }

        // Show login modal
        function showLoginModal() {
            isLoginMode = true;
            document.getElementById('authModalTitle').textContent = 'Log In';
            document.getElementById('authSubmitBtn').textContent = 'Log In';
            document.getElementById('authToggleText').textContent = "Don't have an account? ";
            document.getElementById('authToggle').querySelector('a').textContent = 'Sign Up';
            document.getElementById('authError').textContent = '';
            
            // Show login fields, hide signup fields
            const loginFields = document.getElementById('loginFields');
            const signupFields = document.getElementById('signupFields');
            loginFields.style.display = 'block';
            signupFields.style.display = 'none';
            
            // Add required to login fields, remove from signup fields
            document.getElementById('authEmail').required = true;
            document.getElementById('authPassword').required = true;
            
            // Remove required from signup fields to prevent validation errors
            document.getElementById('signupEmail').required = false;
            document.getElementById('signupFirstName').required = false;
            document.getElementById('signupGender').required = false;
            document.getElementById('signupSchoolId').required = false;
            document.getElementById('signupClass').required = false;
            document.getElementById('signupSection').required = false;
            document.getElementById('signupRollNumber').required = false;
            document.getElementById('signupPassword').required = false;
            document.getElementById('signupPasswordConfirm').required = false;
            
            // Clear form fields
            document.getElementById('authEmail').value = '';
            document.getElementById('authPassword').value = '';
            
            // Show forgot password link in login mode
            const forgotPasswordLink = document.getElementById('forgotPasswordLink');
            if (forgotPasswordLink) forgotPasswordLink.style.display = 'block';
            
            document.getElementById('authModal').style.display = 'flex';
        }

        // Show signup modal
        function showSignupModal() {
            isLoginMode = false;
            document.getElementById('authModalTitle').textContent = 'Sign Up';
            document.getElementById('authSubmitBtn').textContent = 'Sign Up';
            document.getElementById('authToggleText').textContent = 'Already have an account? ';
            document.getElementById('authToggle').querySelector('a').textContent = 'Log In';
            document.getElementById('authError').textContent = '';
            
            // Show signup fields, hide login fields
            const loginFields = document.getElementById('loginFields');
            const signupFields = document.getElementById('signupFields');
            loginFields.style.display = 'none';
            signupFields.style.display = 'block';
            
            // Remove required from login fields to prevent validation errors
            document.getElementById('authEmail').required = false;
            document.getElementById('authPassword').required = false;
            
            // Add required to signup fields
            document.getElementById('signupEmail').required = true;
            document.getElementById('signupFirstName').required = true;
            document.getElementById('signupGender').required = true;
            document.getElementById('signupSchoolId').required = true;
            document.getElementById('signupClass').required = true;
            document.getElementById('signupSection').required = true;
            document.getElementById('signupRollNumber').required = true;
            document.getElementById('signupPassword').required = true;
            document.getElementById('signupPasswordConfirm').required = true;
            
            // Clear all form fields
            document.getElementById('signupEmail').value = '';
            document.getElementById('signupFirstName').value = '';
            document.getElementById('signupLastName').value = '';
            document.getElementById('signupGender').value = '';
            document.getElementById('signupSchoolId').value = '';
            document.getElementById('signupClass').value = '';
            document.getElementById('signupSection').value = '';
            document.getElementById('signupRollNumber').value = '';
            document.getElementById('signupPassword').value = '';
            document.getElementById('signupPasswordConfirm').value = '';
            
            // Hide forgot password link in signup mode
            const forgotPasswordLink = document.getElementById('forgotPasswordLink');
            if (forgotPasswordLink) forgotPasswordLink.style.display = 'none';
            
            document.getElementById('authModal').style.display = 'flex';
        }

        // Close auth modal
        function closeAuthModal() {
            const authModal = document.getElementById('authModal');
            if (authModal) {
                authModal.style.display = 'none';
                console.log('✅ Auth modal closed');
            }
            const authError = document.getElementById('authError');
            if (authError) {
                authError.textContent = '';
            }
            // Reset form
            const authForm = document.getElementById('authForm');
            if (authForm) {
                authForm.reset();
            }
        }

        // Show forgot password modal
        function showForgotPasswordModal() {
            closeAuthModal(); // Close auth modal if open
            const modal = document.getElementById('forgotPasswordModal');
            const requestForm = document.getElementById('forgotPasswordRequestForm');
            const resetForm = document.getElementById('forgotPasswordResetForm');
            const errorEl = document.getElementById('forgotPasswordError');
            const successEl = document.getElementById('forgotPasswordSuccess');
            
            if (!modal) {
                console.error('❌ Forgot password modal not found!');
                return;
            }
            
            // Reset forms
            requestForm.style.display = 'block';
            resetForm.style.display = 'none';
            if (errorEl) errorEl.textContent = '';
            if (successEl) {
                successEl.textContent = '';
                successEl.style.display = 'none';
            }
            const emailInput = document.getElementById('forgotPasswordEmail');
            if (emailInput) emailInput.value = '';
            
            // Check if this is a password reset confirmation (from email link)
            // Check both hash and query parameters
            let type = null;
            let accessToken = null;
            
            if (window.location.hash) {
                const hashParams = new URLSearchParams(window.location.hash.substring(1));
                type = hashParams.get('type') || type;
                accessToken = hashParams.get('access_token') || accessToken;
            }
            
            if (window.location.search) {
                const queryParams = new URLSearchParams(window.location.search);
                type = queryParams.get('type') || type;
                accessToken = queryParams.get('access_token') || accessToken;
            }
            
            if (type === 'recovery' && accessToken) {
                // User clicked password reset link in email
                requestForm.style.display = 'none';
                resetForm.style.display = 'block';
                const titleEl = document.getElementById('forgotPasswordModalTitle');
                if (titleEl) titleEl.textContent = 'Set New Password';
            }
            
            modal.style.display = 'flex';
        }

        // Close forgot password modal
        function closeForgotPasswordModal() {
            const modal = document.getElementById('forgotPasswordModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Handle forgot password request
        async function handleForgotPassword(event) {
            event.preventDefault();
            
            const email = document.getElementById('forgotPasswordEmail').value.trim();
            const errorEl = document.getElementById('forgotPasswordError');
            const successEl = document.getElementById('forgotPasswordSuccess');
            const submitBtn = document.getElementById('forgotPasswordSubmitBtn');
            
            errorEl.textContent = '';
            successEl.textContent = '';
            successEl.style.display = 'none';
            
            if (!email) {
                errorEl.textContent = 'Please enter your email address';
                return false;
            }
            
            if (!supabase) {
                errorEl.textContent = 'Authentication service not available.';
                return false;
            }
            
            submitBtn.disabled = true;
            submitBtn.textContent = 'Sending...';
            
            try {
                const { error } = await supabase.auth.resetPasswordForEmail(email, {
                    redirectTo: `${PASSWORD_RESET_REDIRECT_URL}#type=recovery`
                });
                
                if (error) throw error;
                
                // Success - show message
                successEl.textContent = `Password reset link sent to ${email}. Please check your email (and spam folder) and click the link to reset your password.`;
                successEl.style.color = '#28a745';
                successEl.style.display = 'block';
                document.getElementById('forgotPasswordForm').style.display = 'none';
                
            } catch (err) {
                console.error('❌ Password reset error:', err);
                errorEl.textContent = err.message || 'Failed to send password reset email. Please try again.';
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Send Reset Link';
            }
            
            return false;
        }

        // Handle password reset (when user sets new password)
        async function handleResetPassword(event) {
            event.preventDefault();
            
            const newPassword = document.getElementById('newPassword').value;
            const confirmPassword = document.getElementById('confirmNewPassword').value;
            const errorEl = document.getElementById('resetPasswordError');
            const submitBtn = document.getElementById('resetPasswordSubmitBtn');
            
            errorEl.textContent = '';
            
            if (!newPassword || newPassword.length < 6) {
                errorEl.textContent = 'Password must be at least 6 characters long';
                return false;
            }
            
            if (newPassword !== confirmPassword) {
                errorEl.textContent = 'Passwords do not match';
                return false;
            }
            
            if (!supabase) {
                errorEl.textContent = 'Authentication service not available.';
                return false;
            }
            
            // Verify user has a valid session (from password reset token)
            const { data: { session }, error: sessionError } = await supabase.auth.getSession();
            console.log('🔍 Password reset - Session check:', { 
                hasSession: !!session, 
                sessionError: sessionError?.message,
                userId: session?.user?.id 
            });
            
            if (sessionError) {
                console.error('❌ Session error:', sessionError);
                errorEl.textContent = `Session error: ${sessionError.message}. Please request a new password reset.`;
                return false;
            }
            
            if (!session) {
                console.warn('⚠️ No session found for password reset');
                errorEl.textContent = 'Invalid or expired reset link. The link may have expired or been used already. Please request a new password reset.';
                return false;
            }
            
            submitBtn.disabled = true;
            submitBtn.textContent = 'Updating...';
            
            try {
                const { error } = await supabase.auth.updateUser({
                    password: newPassword
                });
                
                if (error) throw error;
                
                // Success - show message and redirect
                errorEl.textContent = '';
                errorEl.style.color = '#28a745';
                errorEl.textContent = 'Password updated successfully! Redirecting to login...';
                
                // Sign out the user (they were only authenticated via recovery token)
                await supabase.auth.signOut();
                currentUser = null;
                currentUserProfile = null;
                
                // Clean up URL hash
                window.history.replaceState(null, '', window.location.pathname + window.location.search);
                
                // Close modal and show login after a delay
                setTimeout(() => {
                    closeForgotPasswordModal();
                    showLoginModal();
                    updateAuthUI();
                }, 2000);
                
            } catch (err) {
                console.error('❌ Password update error:', err);
                errorEl.style.color = '#dc3545';
                errorEl.textContent = err.message || 'Failed to update password. Please try again.';
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Update Password';
            }
            
            return false;
        }

        // Toggle between login and signup
        function toggleAuthMode(event) {
            event.preventDefault();
            if (isLoginMode) {
                showSignupModal();
            } else {
                showLoginModal();
            }
        }

        // Handle authentication (login or signup)
        async function handleAuth(event) {
            event.preventDefault();
            const errorEl = document.getElementById('authError');
            const submitBtn = document.getElementById('authSubmitBtn');
            const form = document.getElementById('authForm');

            errorEl.textContent = '';
            form.classList.add('loading');
            submitBtn.disabled = true;
            
            // Safety timeout - reset form if it takes too long
            const safetyTimeout = setTimeout(() => {
                console.warn('⚠️ Auth operation taking too long, resetting form...');
                form.classList.remove('loading');
                submitBtn.disabled = false;
                showAuthError('Operation timed out. Please try again.');
            }, 30000); // 30 second timeout

            if (!supabase) {
                showAuthError('Authentication service not available. Please configure Supabase credentials.');
                form.classList.remove('loading');
                submitBtn.disabled = false;
                clearTimeout(safetyTimeout);
                return;
            }

            try {
                if (isLoginMode) {
                    // Login: Get email directly
                    const email = document.getElementById('authEmail').value.trim();
                    const password = document.getElementById('authPassword').value;
                    
                    if (!email) {
                        throw new Error('Email is required');
                    }
                    
                    console.log('🔐 Attempting login with email:', email);
                    
                    const { data, error } = await supabase.auth.signInWithPassword({
                        email: email,
                        password: password
                    });

                    if (error) throw error;
                    
                    // Fetch user profile after successful login
                    currentUserProfile = await fetchUserProfile();
                    // Auth state change listener will handle UI update
                } else {
                    // Sign up: Get all student fields
                    const email = document.getElementById('signupEmail').value.trim();
                    const firstName = document.getElementById('signupFirstName').value.trim();
                    const lastName = document.getElementById('signupLastName').value.trim();
                    const gender = document.getElementById('signupGender').value;
                    const schoolId = parseInt(document.getElementById('signupSchoolId').value);
                    const classNum = parseInt(document.getElementById('signupClass').value);
                    const section = document.getElementById('signupSection').value.trim();
                    const rollNumber = parseInt(document.getElementById('signupRollNumber').value);
                    const password = document.getElementById('signupPassword').value;
                    const passwordConfirm = document.getElementById('signupPasswordConfirm').value;
                    
                    // Validation
                    if (!email) {
                        throw new Error('Email is required');
                    }
                    if (password.length < 6) {
                        throw new Error('Password must be at least 6 characters');
                    }
                    if (password !== passwordConfirm) {
                        throw new Error('Passwords do not match');
                    }
                    if (!firstName) {
                        throw new Error('First name is required');
                    }
                    if (!gender) {
                        throw new Error('Gender is required');
                    }
                    
                    console.log('📝 Attempting signup with email:', email);
                    
                    // Sign up with Supabase (using email directly)
                    console.log('📝 Calling supabase.auth.signUp...');
                    const { data, error } = await supabase.auth.signUp({
                        email: email,
                        password: password,
                        options: {
                            emailRedirectTo: `${SITE_URL}`,
                            data: {
                                first_name: firstName,
                                last_name: lastName
                            }
                        }
                    });
                    console.log('📝 supabase.auth.signUp returned');

                    if (error) {
                        console.error('❌ Signup error:', error);
                        
                        // Special handling: If user already exists but has no profile, create the profile
                        if (error.message && error.message.includes('already registered')) {
                            console.log('ℹ️ User already exists, checking if profile exists...');
                            
                            // Try to sign in first to get the user
                            const { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({
                                email: email,
                                password: password
                            });
                            
                            if (signInError) {
                                // Can't sign in - password might be wrong or user doesn't exist
                                throw new Error('User already registered. If this is your account, please log in instead. If you forgot your password, contact your administrator.');
                            }
                            
                            // User signed in successfully, check if profile exists
                            const existingUser = signInData.user;
                            console.log('✅ Signed in existing user, checking for profile...');
                            
                            const { data: existingProfile, error: profileCheckError } = await supabase
                                .from('user_profiles')
                                .select('*')
                                .eq('user_id', existingUser.id)
                                .single();
                            
                            if (profileCheckError && profileCheckError.code === 'PGRST116') {
                                // Profile doesn't exist - create it
                                console.log('📝 Profile not found, creating profile for existing user...');
                                
                                const { error: profileCreateError } = await supabase
                                    .from('user_profiles')
                                    .insert([{
                                        user_id: existingUser.id,
                                        email: email,
                                        first_name: firstName,
                                        last_name: lastName || null,
                                        gender: gender,
                                        school_id: schoolId,
                                        class: classNum,
                                        section: section,
                                        roll_number: rollNumber
                                    }]);
                                
                                if (profileCreateError) {
                                    console.error('❌ Error creating profile for existing user:', profileCreateError);
                                    throw new Error(`User already registered, but failed to create profile: ${profileCreateError.message}. Please contact your administrator.`);
                                }
                                
                                // Profile created successfully
                                console.log('✅ Profile created for existing user');
                                currentUser = existingUser;
                                currentUserProfile = {
                                    user_id: existingUser.id,
                                    email: email,
                                    first_name: firstName,
                                    last_name: lastName || null,
                                    gender: gender,
                                    school_id: schoolId,
                                    class: classNum,
                                    section: section,
                                    roll_number: rollNumber
                                };
                                
                                // Show success message and update UI
                                errorEl.textContent = 'Profile created successfully! You are now logged in.';
                                errorEl.style.color = '#28a745';
                                form.classList.remove('loading');
                                submitBtn.disabled = false;
                                
                                // Update auth UI in background
                                updateAuthUI().catch(err => {
                                    console.error('❌ Error in updateAuthUI after profile creation:', err);
                                });
                                
                                setTimeout(() => {
                                    closeAuthModal();
                                }, 2000);
                                
                                return; // Exit early, don't throw error
                            } else if (existingProfile) {
                                // Profile already exists
                                throw new Error('User already registered with a complete profile. Please log in instead.');
                            } else {
                                // Some other error checking profile
                                throw new Error(`User already registered, but couldn't check profile: ${profileCheckError?.message || 'Unknown error'}. Please contact your administrator.`);
                            }
                        }
                        
                        // For other errors, throw normally
                        throw error;
                    }
                    
                    console.log('📧 Signup response:', {
                        user: data.user ? 'User created' : 'No user',
                        session: data.session ? 'Session created (auto-confirmed)' : 'No session (email confirmation required)'
                    });
                    
                    // Create user profile in user_profiles table
                    if (data.user) {
                        console.log('📝 Creating user profile in database...');
                        try {
                            const { error: profileError } = await supabase
                                .from('user_profiles')
                                .insert([{
                                    user_id: data.user.id,
                                    email: email,
                                    first_name: firstName,
                                    last_name: lastName || null,
                                    gender: gender,
                                    school_id: schoolId,
                                    class: classNum,
                                    section: section,
                                    roll_number: rollNumber
                                }]);
                            
                            if (profileError) {
                                console.error('❌ Error creating user profile:', profileError);
                                console.error('   Profile error code:', profileError.code);
                                console.error('   Profile error message:', profileError.message);
                                console.error('   Profile error details:', profileError.details);
                                console.error('   Profile error hint:', profileError.hint);
                                // Don't throw - user is created, profile can be added later
                            } else {
                                console.log('✅ User profile created successfully');
                            }
                        } catch (profileErr) {
                            console.error('❌ Error creating user profile (catch):', profileErr);
                        }
                        console.log('📝 User profile creation attempt completed');
                    } else {
                        console.warn('⚠️ No user in signup response, skipping profile creation');
                    }
                    
                    // Check if email confirmation is required
                    if (data.user && !data.session) {
                        // Email confirmation is enabled and required
                        console.log('✅ Email confirmation required - check your inbox');
                        errorEl.textContent = 'Signup successful! Please check your email (and spam folder) to confirm your account.';
                        errorEl.style.color = '#28a745';
                        form.classList.remove('loading');
                        submitBtn.disabled = false;
                        setTimeout(() => {
                            closeAuthModal();
                        }, 5000);
                    } else if (data.user && data.session) {
                        // Auto-logged in (email confirmation is disabled)
                        console.log('✅ Auto-confirmed - email confirmation is disabled in Supabase');
                        // Update currentUser immediately
                        currentUser = data.user;
                        console.log('✅ currentUser set from signup response');
                        
                        // Fetch user profile (don't wait if it times out)
                        fetchUserProfile().then(profile => {
                            currentUserProfile = profile;
                            console.log('✅ User profile fetched after signup:', profile ? 'success' : 'not found');
                        }).catch(err => {
                            console.warn('⚠️ Could not fetch user profile after signup, continuing anyway:', err);
                        });
                        
                        // Update UI immediately
                        errorEl.textContent = 'Signup successful! You are now logged in.';
                        errorEl.style.color = '#28a745';
                        form.classList.remove('loading');
                        submitBtn.disabled = false;
                        
                        // Update auth UI in background
                        updateAuthUI().catch(err => {
                            console.error('❌ Error in updateAuthUI after signup:', err);
                        });
                        
                        setTimeout(() => {
                            closeAuthModal();
                        }, 2000);
                    } else {
                        // Unexpected state
                        console.warn('⚠️ Unexpected signup state:', data);
                        errorEl.textContent = 'Signup completed, but unexpected state. Please try logging in.';
                        errorEl.style.color = '#ffc107';
                        form.classList.remove('loading');
                        submitBtn.disabled = false;
                        setTimeout(() => {
                            closeAuthModal();
                        }, 3000);
                    }
                }
            } catch (err) {
                console.error('❌ Authentication error:', err);
                console.error('   Error details:', JSON.stringify(err, null, 2));
                showAuthError(err.message || (isLoginMode ? 'Login failed. Please check your credentials.' : 'Signup failed. Please try again.'));
                form.classList.remove('loading');
                submitBtn.disabled = false;
            } finally {
                // Always clear the safety timeout
                clearTimeout(safetyTimeout);
            }
        }

        // Show authentication error
        function showAuthError(message) {
            const errorEl = document.getElementById('authError');
            errorEl.textContent = message;
            errorEl.style.color = '#dc3545';
        }

        // Handle logout
        async function handleLogout() {
            if (supabase && currentUser) {
                const { error } = await supabase.auth.signOut();
                if (error) {
                    console.error('Logout error:', error);
                } else {
                    // Clear user state
                    currentUser = null;
                    currentUserProfile = null;
                    
                    // Clear form fields
                    document.getElementById('inlineEmail').value = '';
                    document.getElementById('inlinePassword').value = '';
                    
                    // Update UI (this will clear variants and visual indicators)
                    await updateAuthUI();
                }
            }
        }

        // ============================================================================
        // SUPABASE DATABASE - Score Saving & Retrieval
        // ============================================================================
        // Save session score to Supabase
        async function saveScore() {
            console.log('💾 saveScore() called');
            console.log('💾 currentUser:', currentUser ? { id: currentUser.id, email: currentUser.email } : 'null');
            console.log('💾 supabase:', supabase ? 'initialized' : 'null');
            
            if (!currentUser || !supabase) {
                console.error('❌ User not logged in or Supabase not initialized. Score not saved.');
                console.error('   currentUser:', currentUser);
                console.error('   supabase:', supabase);
                return false;
            }

            if (!currentSession) {
                console.error('❌ currentSession is null or undefined. Cannot save score.');
                return false;
            }

            try {
                // Calculate average time per correct answer
                const avgTime = currentSession.correctCount > 0 
                    ? Math.round((currentSession.totalTime / currentSession.correctCount) * 10) / 10 
                    : 0;
                
                const sessionData = {
                    user_id: currentUser.id,
                    operation: currentSession.operation,
                    variant: currentSession.variant,
                    correct_count: currentSession.correctCount,
                    wrong_count: currentSession.wrongCount,
                    total_time: currentSession.totalTime,
                    average_time: avgTime, // Average time per correct sum
                    total_questions: currentSession.correctCount + currentSession.wrongCount,
                    session_data: currentSession.results,
                    passed: currentSession.passed || false, // Store pass/fail result
                    completed_at: new Date().toISOString()
                };

                console.log('💾 Attempting to save session data:', {
                    user_id: sessionData.user_id,
                    operation: sessionData.operation,
                    variant: sessionData.variant,
                    correct_count: sessionData.correct_count,
                    wrong_count: sessionData.wrong_count,
                    total_questions: sessionData.total_questions,
                    passed: sessionData.passed
                });

                const { data, error } = await supabase
                    .from('user_scores')
                    .insert([sessionData])
                    .select();

                if (error) {
                    console.error('❌ Supabase insert error:', error);
                    console.error('   Error code:', error.code);
                    console.error('   Error message:', error.message);
                    console.error('   Error details:', error.details);
                    console.error('   Error hint:', error.hint);
                    throw error;
                }

                console.log('✅ Score saved successfully:', data);
                return true;
            } catch (error) {
                console.error('❌ Error saving score:', error);
                console.error('   Full error object:', JSON.stringify(error, null, 2));
                return false;
            }
        }

        // Retrieve user scores from Supabase
        async function getUserScores(operation = null, variant = null) {
            if (!currentUser || !supabase) {
                console.log('User not logged in or Supabase not initialized. Cannot retrieve scores.');
                return null;
            }

            try {
                let query = supabase
                    .from('user_scores')
                    .select('*')
                    .eq('user_id', currentUser.id)
                    .order('completed_at', { ascending: false });

                if (operation) query = query.eq('operation', operation);
                if (variant) query = query.eq('variant', variant);

                const { data, error } = await query;

                if (error) throw error;
                return data || [];
            } catch (error) {
                console.error('Error retrieving scores:', error);
                return null;
            }
        }

        // Get user progress from Supabase
        async function getUserProgress() {
            if (!currentUser || !supabase) {
                return null;
            }

            try {
                const { data: scores, error } = await supabase
                    .from('user_scores')
                    .select('*')
                    .eq('user_id', currentUser.id);

                if (error) throw error;

                // Calculate progress statistics
                const totalSessions = scores?.length || 0;
                let totalQuestions = 0;
                let correctAnswers = 0;
                let wrongAnswers = 0;
                const variantsCompleted = new Set();

                scores?.forEach(score => {
                    totalQuestions += score.total_questions || 0;
                    correctAnswers += score.correct_count || 0;
                    wrongAnswers += score.wrong_count || 0;
                    if (score.operation && score.variant) {
                        variantsCompleted.add(`${score.operation}_${score.variant}`);
                    }
                });

                return {
                    totalSessions,
                    totalQuestions,
                    correctAnswers,
                    wrongAnswers,
                    variantsCompleted: Array.from(variantsCompleted)
                };
            } catch (error) {
                console.error('Error retrieving progress:', error);
                return null;
            }
        }

        // Update endSession to save scores
        // Store the original endSession function in a closure to avoid infinite recursion
        (function() {
            const originalEndSession = endSession;
            window.endSession = function() {
                console.log('🔄 endSession wrapper called');
                // Call the original endSession function
                originalEndSession.call(this);
                // Save score if user is logged in
                console.log('🔄 Checking if user is logged in for score saving...');
                console.log('🔄 currentUser:', currentUser ? { id: currentUser.id, email: currentUser.email } : 'null');
                if (currentUser) {
                    console.log('🔄 User is logged in, calling saveScore()...');
                    saveScore().then(success => {
                        if (success) {
                            console.log('✅ Session data saved to server, refreshing dashboard...');
                            // Refresh passed and failed variants to update dashboard (sequential to avoid race condition)
                            fetchPassedVariants()
                                .then(() => {
                                    console.log('✅ Passed variants refreshed after score save');
                                    return fetchFailedVariants();
                                })
                                .then(() => {
                                    console.log('✅ Failed variants refreshed after score save');
                                    // Update operation completion status (green cards)
                                    updateOperationCompletionStatus();
                                    
                                    // Always refresh variant cards if operation is selected and dashboard is visible
                                    const dashboardSection = document.getElementById('dashboardSection');
                                    if (selectedOperation && dashboardSection && !dashboardSection.classList.contains('hidden')) {
                                        console.log('🔄 Refreshing variant cards after score save for:', selectedOperation);
                                        loadVariantsForOperation(selectedOperation);
                                    } else {
                                        console.log('ℹ️ Dashboard not visible or no operation selected - will refresh when dashboard is shown');
                                    }
                                })
                                .catch(err => {
                                    console.warn('⚠️ Error refreshing variants:', err);
                                });
                        } else {
                            console.error('❌ Failed to save session data to server');
                        }
                    }).catch(error => {
                        console.error('❌ Error in saveScore promise:', error);
                    });
                } else {
                    console.warn('⚠️ User not logged in, score will not be saved');
                }
            };
        })();

        // Check for password reset IMMEDIATELY (before DOMContentLoaded)
        // Check both hash (#) and query parameters (?)
        (function checkPasswordResetImmediate() {
            let type = null;
            let accessToken = null;
            
            // Check hash parameters
            if (window.location.hash) {
                const hashParams = new URLSearchParams(window.location.hash.substring(1));
                type = hashParams.get('type') || type;
                accessToken = hashParams.get('access_token') || accessToken;
            }
            
            // Check query parameters (some redirects use ? instead of #)
            if (window.location.search) {
                const queryParams = new URLSearchParams(window.location.search);
                type = queryParams.get('type') || type;
                accessToken = queryParams.get('access_token') || accessToken;
            }
            
            if (type === 'recovery' && accessToken) {
                // Set flag to show modal when DOM is ready
                window._passwordResetDetected = true;
            }
        })();

        // Initialize everything when page loads
        window.addEventListener('DOMContentLoaded', () => {
            // Check for password reset link - check both hash and query params
            let type = null;
            let accessToken = null;
            
            if (window.location.hash) {
                const hashParams = new URLSearchParams(window.location.hash.substring(1));
                type = hashParams.get('type') || type;
                accessToken = hashParams.get('access_token') || accessToken;
            }
            
            if (window.location.search) {
                const queryParams = new URLSearchParams(window.location.search);
                type = queryParams.get('type') || type;
                accessToken = queryParams.get('access_token') || accessToken;
            }
            
            // IMMEDIATELY show password reset form if recovery link detected
            if ((type === 'recovery' && accessToken) || window._passwordResetDetected) {
                // Show modal immediately, don't wait for Supabase
                setTimeout(() => {
                    try {
                        showForgotPasswordModal();
                    } catch (err) {
                        console.error('❌ Error showing password reset modal:', err);
                    }
                }, 300);
                // Store flag to show modal after Supabase initializes (as backup)
                window._showPasswordReset = true;
            }
            
            // Handle email confirmation callback (for signup only - password reset handled in initSupabase)
            if (type === 'signup') {
                handleEmailConfirmation();
            }
            
            // Wait for Supabase library to load
            function tryInitSupabase(attempts = 0) {
                if (window.supabase && window.supabase.createClient) {
                    initSupabase();
                } else if (attempts < 5) {
                    // Retry up to 5 times (5 seconds total)
                    setTimeout(() => tryInitSupabase(attempts + 1), 1000);
                } else {
                    console.error('❌ Supabase library failed to load after multiple attempts.');
                    console.error('Please check your internet connection and the script tag.');
                    const authStatus = document.getElementById('authStatus');
                    if (authStatus) {
                        authStatus.textContent = 'Supabase library failed to load';
                        authStatus.className = 'auth-status logged-out';
                    }
                }
            }
            
            tryInitSupabase();
        });

        // Close auth modal when clicking outside
        document.getElementById('authModal')?.addEventListener('click', (e) => {
            if (e.target.id === 'authModal') {
                closeAuthModal();
            }
        });

        // Close forgot password modal when clicking outside
        document.getElementById('forgotPasswordModal')?.addEventListener('click', (e) => {
            if (e.target.id === 'forgotPasswordModal') {
                closeForgotPasswordModal();
            }
        });
    </script>
</body>
</html>

